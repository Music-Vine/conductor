---
phase: 05-bulk-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/assets/bulk/route.ts
  - src/app/api/assets/bulk/ids/route.ts
  - src/app/api/users/bulk/route.ts
  - src/app/api/users/bulk/ids/route.ts
  - src/lib/bulk-operations/sse.ts
  - src/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Bulk operations stream progress via Server-Sent Events"
    - "Progress includes processed count, total, percentage, and current item name"
    - "First error stops processing and streams error event"
    - "IDs endpoint returns all IDs matching current filters for Select All"
  artifacts:
    - path: "src/app/api/assets/bulk/route.ts"
      provides: "Asset bulk operations with SSE progress"
      exports: ["POST"]
    - path: "src/app/api/users/bulk/route.ts"
      provides: "User bulk operations with SSE progress"
      exports: ["POST"]
    - path: "src/app/api/assets/bulk/ids/route.ts"
      provides: "Fetch all asset IDs matching filters"
      exports: ["GET"]
    - path: "src/lib/bulk-operations/sse.ts"
      provides: "SSE stream creation utilities"
      exports: ["createSSEStream", "sendProgress", "sendError", "sendComplete"]
  key_links:
    - from: "src/app/api/assets/bulk/route.ts"
      to: "src/lib/bulk-operations/sse.ts"
      via: "SSE stream utilities"
      pattern: "createSSEStream"
---

<objective>
Create mock bulk operation API routes with Server-Sent Events for real-time progress streaming.

Purpose: Enable async bulk operations with progress tracking per CONTEXT decision. Mock endpoints simulate processing time and stream incremental updates so staff can monitor progress in toast notifications.

Output: Bulk API routes for assets and users with SSE progress streaming, plus ID fetching endpoints for Select All functionality.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-bulk-operations/05-CONTEXT.md
@.planning/phases/05-bulk-operations/05-RESEARCH.md

# Existing API patterns
@src/app/api/assets/route.ts
@src/app/api/users/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE streaming utilities</name>
  <files>src/lib/bulk-operations/sse.ts</files>
  <action>
Create SSE streaming utilities in `src/lib/bulk-operations/sse.ts`:

**Types:**
```typescript
interface ProgressEvent {
  type: 'progress'
  processed: number
  total: number
  percentage: number
  currentItem: string // e.g., "Summer Vibes.mp3" or "john@example.com"
  estimatedSecondsRemaining: number | null
}

interface ErrorEvent {
  type: 'error'
  message: string
  processed: number
  total: number
  failedItem: string
}

interface CompleteEvent {
  type: 'complete'
  processed: number
  total: number
  operationId: string // For audit log reference
}

type SSEEvent = ProgressEvent | ErrorEvent | CompleteEvent
```

**Utilities:**
```typescript
// Create encoder once
const encoder = new TextEncoder()

// Format SSE data line
export function formatSSEData(event: SSEEvent): Uint8Array {
  return encoder.encode(`data: ${JSON.stringify(event)}\n\n`)
}

// Create SSE Response headers
export function createSSEHeaders(): Headers {
  return new Headers({
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
  })
}

// Helper to estimate time remaining based on items processed and elapsed time
export function estimateSecondsRemaining(
  processed: number,
  total: number,
  startTime: number
): number | null {
  if (processed === 0) return null
  const elapsed = (Date.now() - startTime) / 1000
  const rate = processed / elapsed
  const remaining = total - processed
  return Math.round(remaining / rate)
}

// Generate operation ID for audit
export function generateOperationId(): string {
  return `bulk-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}
```
  </action>
  <verify>npx tsc --noEmit passes with no errors related to sse.ts</verify>
  <done>SSE utilities exported: formatSSEData, createSSEHeaders, estimateSecondsRemaining, generateOperationId</done>
</task>

<task type="auto">
  <name>Task 2: Create bulk asset operations API with SSE</name>
  <files>src/app/api/assets/bulk/route.ts, src/app/api/assets/bulk/ids/route.ts, src/middleware.ts</files>
  <action>
Create `src/app/api/assets/bulk/route.ts` for bulk asset operations:

**POST handler:**
- Request body: `{ action: BulkAction, assetIds: string[], payload?: object }`
- BulkAction: 'approve' | 'reject' | 'delete' | 'archive' | 'takedown' | 'add-tag' | 'remove-tag' | 'add-to-collection' | 'remove-from-collection' | 'set-platform'
- Returns SSE stream with progress events

**Implementation:**
```typescript
export async function POST(request: Request) {
  const { action, assetIds, payload } = await request.json()
  const operationId = generateOperationId()
  const startTime = Date.now()

  const stream = new ReadableStream({
    async start(controller) {
      const total = assetIds.length

      for (let i = 0; i < assetIds.length; i++) {
        const assetId = assetIds[i]

        try {
          // Simulate operation (50-150ms per item)
          await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100))

          // Simulate random failure (2% chance) for testing error handling
          if (Math.random() < 0.02) {
            throw new Error(`Failed to ${action} asset: permission denied`)
          }

          const processed = i + 1
          const progress: ProgressEvent = {
            type: 'progress',
            processed,
            total,
            percentage: Math.round((processed / total) * 100),
            currentItem: `Asset ${assetId.slice(0, 8)}...`, // Truncated ID as mock name
            estimatedSecondsRemaining: estimateSecondsRemaining(processed, total, startTime),
          }
          controller.enqueue(formatSSEData(progress))

        } catch (error) {
          // Stop on first error per CONTEXT decision
          const errorEvent: ErrorEvent = {
            type: 'error',
            message: error instanceof Error ? error.message : 'Unknown error',
            processed: i,
            total,
            failedItem: assetId,
          }
          controller.enqueue(formatSSEData(errorEvent))
          controller.close()
          return
        }
      }

      // Success
      const complete: CompleteEvent = {
        type: 'complete',
        processed: total,
        total,
        operationId,
      }
      controller.enqueue(formatSSEData(complete))
      controller.close()
    },
  })

  return new Response(stream, { headers: createSSEHeaders() })
}
```

Create `src/app/api/assets/bulk/ids/route.ts` for Select All:
- GET handler that accepts same filter params as /api/assets
- Returns `{ ids: string[], total: number }` with all matching asset IDs
- Mock: Generate consistent IDs based on filter params using seeded random

**Update middleware.ts:**
Add to publicPaths array:
- '/api/assets/bulk'
- '/api/assets/bulk/ids'
  </action>
  <verify>
1. npx tsc --noEmit passes
2. curl -X POST http://localhost:3000/api/assets/bulk -H "Content-Type: application/json" -d '{"action":"approve","assetIds":["1","2","3"]}' shows SSE events
  </verify>
  <done>
- /api/assets/bulk POST returns SSE stream with progress, error, or complete events
- /api/assets/bulk/ids GET returns all IDs matching filters
- Middleware updated to allow bulk routes
  </done>
</task>

<task type="auto">
  <name>Task 3: Create bulk user operations API with SSE</name>
  <files>src/app/api/users/bulk/route.ts, src/app/api/users/bulk/ids/route.ts, src/middleware.ts</files>
  <action>
Create `src/app/api/users/bulk/route.ts` for bulk user operations:

**POST handler:**
- Request body: `{ action: BulkUserAction, userIds: string[], payload?: object }`
- BulkUserAction: 'suspend' | 'unsuspend' | 'delete'
- Returns SSE stream with progress events (same pattern as assets)

Create `src/app/api/users/bulk/ids/route.ts` for Select All:
- GET handler that accepts same filter params as /api/users (query, status, tier)
- Returns `{ ids: string[], total: number }` with all matching user IDs
- Mock: Generate consistent IDs based on filter params

**Implementation follows same pattern as asset bulk routes.**

For user operations:
- 'suspend': Simulate setting user status to suspended
- 'unsuspend': Simulate setting user status to active
- 'delete': Simulate user deletion

**Update middleware.ts:**
Add to publicPaths array:
- '/api/users/bulk'
- '/api/users/bulk/ids'
  </action>
  <verify>
1. npx tsc --noEmit passes
2. curl -X POST http://localhost:3000/api/users/bulk -H "Content-Type: application/json" -d '{"action":"suspend","userIds":["1","2","3"]}' shows SSE events
  </verify>
  <done>
- /api/users/bulk POST returns SSE stream with progress events
- /api/users/bulk/ids GET returns all IDs matching filters
- Middleware updated to allow user bulk routes
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes
2. SSE utilities exist: `ls src/lib/bulk-operations/sse.ts`
3. Bulk routes exist: `ls src/app/api/assets/bulk/route.ts src/app/api/users/bulk/route.ts`
4. Middleware allows bulk routes: `grep "bulk" src/middleware.ts`
5. Build succeeds: `npm run build`
</verification>

<success_criteria>
- SSE streaming utilities created with proper event types
- Asset bulk operations route handles: approve, reject, delete, archive, takedown, add-tag, remove-tag, add-to-collection, remove-from-collection, set-platform
- User bulk operations route handles: suspend, unsuspend, delete
- All routes return SSE streams with progress/error/complete events
- IDs routes return all matching IDs for Select All functionality
- Stop-on-first-error implemented per CONTEXT decision
- Build passes: `npm run build`
</success_criteria>

<output>
After completion, create `.planning/phases/05-bulk-operations/05-02-SUMMARY.md`
</output>
