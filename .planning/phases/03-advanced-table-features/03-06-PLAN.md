---
phase: 03-advanced-table-features
plan: 06
type: execute
wave: 3
depends_on: ["03-01"]
files_modified:
  - src/app/api/search/route.ts
  - src/hooks/useGlobalSearch.tsx
autonomous: true

must_haves:
  truths:
    - "API returns search results across users, assets, and payees"
    - "Results are weighted by relevance using fuzzy matching"
    - "Dynamic result counts show more of entity types that match better"
    - "Loading state shown while searching"
  artifacts:
    - path: "src/app/api/search/route.ts"
      provides: "Mock search API endpoint"
      exports: ["GET"]
      min_lines: 40
    - path: "src/hooks/useGlobalSearch.tsx"
      provides: "Hook for global search with fuse.js"
      exports: ["useGlobalSearch"]
      min_lines: 80
  key_links:
    - from: "src/hooks/useGlobalSearch.tsx"
      to: "fuse.js"
      via: "Fuse constructor"
      pattern: "new Fuse"
    - from: "src/hooks/useGlobalSearch.tsx"
      to: "src/app/api/search/route.ts"
      via: "fetch call"
      pattern: "api/search"
---

<objective>
Create global search API and hook that searches across users, assets, and payees with fuzzy matching and dynamic result weighting.

Purpose: Enable staff to quickly find any entity in the system using the command palette. Fuzzy search handles typos and partial matches.
Output: Working search that returns weighted results across all entity types.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-table-features/03-CONTEXT.md
@.planning/phases/03-advanced-table-features/03-RESEARCH.md
@src/types/user.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock search API endpoint</name>
  <files>src/app/api/search/route.ts</files>
  <action>
Create `src/app/api/search/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'

// Mock searchable data - in production this would query the database
const mockUsers = [
  { id: 'u1', type: 'user', email: 'john@example.com', name: 'John Smith', subscription: 'pro' },
  { id: 'u2', type: 'user', email: 'jane@company.org', name: 'Jane Doe', subscription: 'enterprise' },
  { id: 'u3', type: 'user', email: 'bob@startup.io', name: 'Bob Wilson', subscription: 'creator' },
  { id: 'u4', type: 'user', email: 'alice@agency.com', name: 'Alice Brown', subscription: 'pro' },
  { id: 'u5', type: 'user', email: 'charlie@music.co', name: 'Charlie Davis', subscription: 'free' },
]

const mockAssets = [
  { id: 'a1', type: 'asset', title: 'Summer Vibes', tags: ['upbeat', 'summer', 'pop'], contributor: 'John Artist' },
  { id: 'a2', type: 'asset', title: 'Corporate Success', tags: ['corporate', 'business', 'motivational'], contributor: 'Studio Pro' },
  { id: 'a3', type: 'asset', title: 'Cinematic Epic', tags: ['cinematic', 'dramatic', 'orchestral'], contributor: 'Film Composer' },
  { id: 'a4', type: 'asset', title: 'Chill Lofi Beat', tags: ['lofi', 'chill', 'ambient'], contributor: 'Lofi Producer' },
  { id: 'a5', type: 'asset', title: 'Action Trailer', tags: ['action', 'trailer', 'intense'], contributor: 'Trailer Music Co' },
]

const mockPayees = [
  { id: 'p1', type: 'payee', name: 'John Artist', email: 'john@artist.com' },
  { id: 'p2', type: 'payee', name: 'Studio Pro LLC', email: 'billing@studiopro.com' },
  { id: 'p3', type: 'payee', name: 'Film Composer Inc', email: 'accounts@filmcomposer.com' },
  { id: 'p4', type: 'payee', name: 'Lofi Producer', email: 'lofi@producer.net' },
  { id: 'p5', type: 'payee', name: 'Trailer Music Company', email: 'finance@trailermusic.co' },
]

export interface SearchResult {
  id: string
  type: 'user' | 'asset' | 'payee'
  title: string
  subtitle: string
  url: string
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const query = searchParams.get('q')

  if (!query || query.length < 2) {
    return NextResponse.json({ results: [], query: '' })
  }

  // Simulate network latency
  await new Promise(resolve => setTimeout(resolve, 100))

  // Return all data for client-side fuzzy search
  // In production, this could do server-side search for very large datasets
  const searchableData = {
    users: mockUsers.map(u => ({
      id: u.id,
      type: 'user' as const,
      title: u.name || u.email,
      subtitle: u.email,
      searchFields: { email: u.email, name: u.name, subscription: u.subscription },
      url: `/users/${u.id}`,
    })),
    assets: mockAssets.map(a => ({
      id: a.id,
      type: 'asset' as const,
      title: a.title,
      subtitle: `by ${a.contributor}`,
      searchFields: { title: a.title, tags: a.tags.join(' '), contributor: a.contributor },
      url: `/assets/${a.id}`,
    })),
    payees: mockPayees.map(p => ({
      id: p.id,
      type: 'payee' as const,
      title: p.name,
      subtitle: p.email,
      searchFields: { name: p.name, email: p.email },
      url: `/payees/${p.id}`,
    })),
  }

  return NextResponse.json({ searchableData, query })
}
```

Key implementation:
- Mock data for users, assets, payees (will be real database in production)
- Returns all searchable data for client-side fuzzy matching
- Normalized SearchResult format with title, subtitle, url
- 100ms simulated latency for realistic testing
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Start dev server and test: `curl "http://localhost:3000/api/search?q=john"` returns data
  </verify>
  <done>Mock search API returns searchable data for users, assets, and payees</done>
</task>

<task type="auto">
  <name>Task 2: Create useGlobalSearch hook</name>
  <files>src/hooks/useGlobalSearch.tsx</files>
  <action>
Create `src/hooks/useGlobalSearch.tsx`:

```typescript
'use client'

import { useState, useMemo, useCallback } from 'react'
import { useQuery } from '@tanstack/react-query'
import Fuse from 'fuse.js'

export interface SearchResultItem {
  id: string
  type: 'user' | 'asset' | 'payee'
  title: string
  subtitle: string
  url: string
  score?: number
}

interface SearchableItem {
  id: string
  type: 'user' | 'asset' | 'payee'
  title: string
  subtitle: string
  url: string
  searchFields: Record<string, string>
}

interface SearchData {
  users: SearchableItem[]
  assets: SearchableItem[]
  payees: SearchableItem[]
}

// Fetch searchable data (cached for 5 minutes)
async function fetchSearchData(): Promise<SearchData> {
  const response = await fetch('/api/search?q=_prefetch', {
    credentials: 'include',
  })
  if (!response.ok) {
    throw new Error('Failed to fetch search data')
  }
  const data = await response.json()
  return data.searchableData
}

interface UseGlobalSearchOptions {
  maxResults?: number
  minQueryLength?: number
}

export function useGlobalSearch(
  query: string,
  options: UseGlobalSearchOptions = {}
) {
  const { maxResults = 10, minQueryLength = 2 } = options
  const [isSearching, setIsSearching] = useState(false)

  // Prefetch and cache searchable data
  const { data: searchData, isLoading: isLoadingData } = useQuery({
    queryKey: ['search-data'],
    queryFn: fetchSearchData,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  })

  // Create Fuse instances for each entity type
  const fuseInstances = useMemo(() => {
    if (!searchData) return null

    const fuseOptions = {
      threshold: 0.3,
      includeScore: true,
      ignoreLocation: true,
    }

    return {
      users: new Fuse(searchData.users, {
        ...fuseOptions,
        keys: [
          { name: 'searchFields.email', weight: 2 },
          { name: 'searchFields.name', weight: 1.5 },
          { name: 'searchFields.subscription', weight: 1 },
        ],
      }),
      assets: new Fuse(searchData.assets, {
        ...fuseOptions,
        keys: [
          { name: 'searchFields.title', weight: 2 },
          { name: 'searchFields.tags', weight: 1.5 },
          { name: 'searchFields.contributor', weight: 1 },
        ],
      }),
      payees: new Fuse(searchData.payees, {
        ...fuseOptions,
        keys: [
          { name: 'searchFields.name', weight: 2 },
          { name: 'searchFields.email', weight: 1.5 },
        ],
      }),
    }
  }, [searchData])

  // Perform fuzzy search with dynamic result weighting
  const results = useMemo<SearchResultItem[]>(() => {
    if (!fuseInstances || !query || query.length < minQueryLength) {
      return []
    }

    setIsSearching(true)

    // Search all entity types
    const userResults = fuseInstances.users.search(query)
    const assetResults = fuseInstances.assets.search(query)
    const payeeResults = fuseInstances.payees.search(query)

    // Calculate average scores (lower is better in Fuse.js)
    const avgScores = {
      users: userResults.length > 0
        ? userResults.reduce((acc, r) => acc + (r.score || 1), 0) / userResults.length
        : 1,
      assets: assetResults.length > 0
        ? assetResults.reduce((acc, r) => acc + (r.score || 1), 0) / assetResults.length
        : 1,
      payees: payeeResults.length > 0
        ? payeeResults.reduce((acc, r) => acc + (r.score || 1), 0) / payeeResults.length
        : 1,
    }

    // Dynamic allocation: show more of entity types with better matches
    // Sort by best average score (lower is better)
    const sortedTypes = (Object.entries(avgScores) as [keyof typeof avgScores, number][])
      .filter(([type]) => {
        const results = { users: userResults, assets: assetResults, payees: payeeResults }
        return results[type].length > 0
      })
      .sort(([, a], [, b]) => a - b)
      .map(([type]) => type)

    // Allocate: 60% to best, 30% to second, 10% to third
    const allocations: Record<string, number> = { users: 0, assets: 0, payees: 0 }
    if (sortedTypes.length > 0) allocations[sortedTypes[0]] = Math.ceil(maxResults * 0.6)
    if (sortedTypes.length > 1) allocations[sortedTypes[1]] = Math.ceil(maxResults * 0.3)
    if (sortedTypes.length > 2) allocations[sortedTypes[2]] = Math.ceil(maxResults * 0.1)

    // Combine results
    const combined: SearchResultItem[] = [
      ...userResults.slice(0, allocations.users).map(r => ({
        ...r.item,
        score: r.score,
      })),
      ...assetResults.slice(0, allocations.assets).map(r => ({
        ...r.item,
        score: r.score,
      })),
      ...payeeResults.slice(0, allocations.payees).map(r => ({
        ...r.item,
        score: r.score,
      })),
    ].sort((a, b) => (a.score || 0) - (b.score || 0))

    setIsSearching(false)
    return combined.slice(0, maxResults)
  }, [fuseInstances, query, minQueryLength, maxResults])

  // Manual search function for imperative use
  const search = useCallback((searchQuery: string): SearchResultItem[] => {
    if (!fuseInstances || searchQuery.length < minQueryLength) {
      return []
    }

    const allResults = [
      ...fuseInstances.users.search(searchQuery),
      ...fuseInstances.assets.search(searchQuery),
      ...fuseInstances.payees.search(searchQuery),
    ]
      .map(r => ({ ...r.item, score: r.score }))
      .sort((a, b) => (a.score || 0) - (b.score || 0))

    return allResults.slice(0, maxResults)
  }, [fuseInstances, minQueryLength, maxResults])

  return {
    results,
    isLoading: isLoadingData,
    isSearching,
    search,
    hasData: !!searchData,
  }
}
```

Key implementation details:
- Pre-loads searchable data and caches for 5 minutes
- Uses Fuse.js for fuzzy matching with weighted fields
- Dynamic result allocation: better-matching entity types get more results
- Returns normalized SearchResultItem with id, type, title, subtitle, url
- Provides both reactive (results) and imperative (search function) APIs
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Hook exports useGlobalSearch
  </verify>
  <done>
- useGlobalSearch hook created with Fuse.js integration
- Weighted search across users, assets, payees
- Dynamic result allocation based on match quality
- Data pre-fetched and cached for 5 minutes
  </done>
</task>

</tasks>

<verification>
After both tasks:
```bash
npx tsc --noEmit
npm run build
```
Test by importing useGlobalSearch in a component and verifying it returns results.
</verification>

<success_criteria>
- Mock search API returns data for all entity types
- useGlobalSearch hook performs fuzzy matching
- Results weighted by relevance
- Dynamic allocation shows more of better-matching types
- Loading state available while searching
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-table-features/03-06-SUMMARY.md`
</output>
