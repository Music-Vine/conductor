---
phase: 08-legacy-system-migration
plan: 05
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/contributors/route.ts
  - src/app/api/contributors/[id]/route.ts
  - src/app/api/contributors/[id]/payees/route.ts
  - src/app/api/contributors/[id]/assets/route.ts
  - src/app/api/payees/route.ts
  - src/app/api/payees/[id]/route.ts
  - src/app/api/payees/[id]/contributors/route.ts
autonomous: true

must_haves:
  truths:
    - "All contributor and payee route handlers conditionally proxy to real backend"
    - "Contributor list, detail, payees, and assets routes have proxy paths"
    - "Payee list, detail, and contributors routes have proxy paths"
    - "Mock data generation preserved as fallback"
  artifacts:
    - path: "src/app/api/contributors/route.ts"
      provides: "Conditional proxy for contributor list/create"
      contains: "proxyToBackend"
    - path: "src/app/api/payees/route.ts"
      provides: "Conditional proxy for payee list/create"
      contains: "proxyToBackend"
    - path: "src/app/api/contributors/[id]/payees/route.ts"
      provides: "Conditional proxy for contributor-payee relationships"
      contains: "proxyToBackend"
  key_links:
    - from: "src/app/api/contributors/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
    - from: "src/app/api/payees/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
---

<objective>
Add conditional BFF proxy logic to all 7 contributor and payee route handlers, preserving existing mock data as fallback.

Purpose: Enable the contributors and payees sections of Conductor to work against real backend data when the feature flag is enabled.
Output: 7 contributor/payee route handlers updated with proxy logic.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md
@src/lib/api/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proxy logic to contributor routes</name>
  <files>
    src/app/api/contributors/route.ts
    src/app/api/contributors/[id]/route.ts
    src/app/api/contributors/[id]/payees/route.ts
    src/app/api/contributors/[id]/assets/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to all 4 contributor route files.

**Backend paths:**
- `GET /api/contributors` -> `/admin/contributors` (forwards query, status, page, limit)
- `POST /api/contributors` -> `/admin/contributors` (forward body: name, email, phone, etc.)
- `GET /api/contributors/[id]` -> `/admin/contributors/{id}`
- `PATCH /api/contributors/[id]` -> `/admin/contributors/{id}` (forward body)
- `GET /api/contributors/[id]/payees` -> `/admin/contributors/{id}/payees`
- `POST /api/contributors/[id]/payees` -> `/admin/contributors/{id}/payees` (forward body: payeeId, percentageRate)
- `DELETE /api/contributors/[id]/payees` -> `/admin/contributors/{id}/payees` (forward body: payeeId)
- `GET /api/contributors/[id]/assets` -> `/admin/contributors/{id}/assets` (forwards page, limit)

For each handler, follow the standard pattern:
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const result = await proxyToBackend(request, `/admin/contributors/${id}/payees`)
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else return NextResponse.json(result.data)
  // ... existing mock code ...
}
```

For POST/DELETE/PATCH routes, read body once and use in both paths:
```typescript
const body = await request.json()
const result = await proxyToBackend(request, `/admin/contributors/${id}/payees`, {
  method: 'POST',
  body,
})
```

**Rate validation note:** The contributor payees POST route validates that percentage rates sum to 100. In proxy mode, this validation happens on the backend. The mock path retains its own validation.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>All 4 contributor routes have conditional proxy logic with mock fallback</done>
</task>

<task type="auto">
  <name>Task 2: Add proxy logic to payee routes</name>
  <files>
    src/app/api/payees/route.ts
    src/app/api/payees/[id]/route.ts
    src/app/api/payees/[id]/contributors/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to all 3 payee route files.

**Backend paths:**
- `GET /api/payees` -> `/admin/payees` (forwards query, status, page, limit)
- `POST /api/payees` -> `/admin/payees` (forward body: name, email, paymentMethod, etc.)
- `GET /api/payees/[id]` -> `/admin/payees/{id}`
- `PATCH /api/payees/[id]` -> `/admin/payees/{id}` (forward body)
- `GET /api/payees/[id]/contributors` -> `/admin/payees/{id}/contributors`

Same pattern as contributor routes:
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function GET(request: NextRequest) {
  const result = await proxyToBackend(request, '/admin/payees')
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else return NextResponse.json(result.data)
  // ... existing mock code ...
}
```

For routes with dynamic params:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const result = await proxyToBackend(request, `/admin/payees/${id}/contributors`)
  // ...
}
```
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>All 7 contributor and payee routes have conditional proxy logic, mock fallback preserved</done>
</task>

</tasks>

<verification>
1. All 7 files import `proxyToBackend`
2. GET, POST, PATCH, DELETE methods all have proxy checks
3. Mock data generation unchanged
4. `npm run build` passes
</verification>

<success_criteria>
- Contributor and payee routes all support conditional proxying
- Relationship management (payee assignment, rate setting) proxied correctly
- Mock mode behavior identical to before
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-05-SUMMARY.md`
</output>
