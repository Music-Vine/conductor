---
phase: 08-legacy-system-migration
plan: 06
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/collections/route.ts
  - src/app/api/collections/[id]/route.ts
  - src/app/api/collections/[id]/assets/route.ts
  - src/app/api/collections/[id]/assets/[assetId]/route.ts
  - src/app/api/activity/route.ts
  - src/app/api/search/route.ts
  - src/app/api/audit/route.ts
  - src/app/api/financials/export/route.ts
autonomous: true

must_haves:
  truths:
    - "Collection routes conditionally proxy to real backend"
    - "Activity feed route conditionally proxies to real backend"
    - "Global search route conditionally proxies to real backend"
    - "Audit and financial export routes conditionally proxy to real backend"
    - "Mock data preserved as fallback for all routes"
  artifacts:
    - path: "src/app/api/collections/route.ts"
      provides: "Conditional proxy for collection list/create"
      contains: "proxyToBackend"
    - path: "src/app/api/activity/route.ts"
      provides: "Conditional proxy for activity feed"
      contains: "proxyToBackend"
    - path: "src/app/api/search/route.ts"
      provides: "Conditional proxy for global search"
      contains: "proxyToBackend"
  key_links:
    - from: "src/app/api/collections/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
    - from: "src/app/api/activity/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
---

<objective>
Add conditional BFF proxy logic to the 8 remaining route handlers: collections (4), activity, search, audit, and financial export.

Purpose: Complete the proxy integration across all route handlers, ensuring every API endpoint in Conductor can operate against real backend data.
Output: 8 route handlers updated with proxy logic, completing the full proxy coverage.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md
@src/lib/api/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proxy logic to collection routes</name>
  <files>
    src/app/api/collections/route.ts
    src/app/api/collections/[id]/route.ts
    src/app/api/collections/[id]/assets/route.ts
    src/app/api/collections/[id]/assets/[assetId]/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to all 4 collection route files.

**Backend paths:**
- `GET /api/collections` -> `/admin/collections` (forwards query, page, limit)
- `POST /api/collections` -> `/admin/collections` (forward body: name, description)
- `GET /api/collections/[id]` -> `/admin/collections/{id}`
- `PATCH /api/collections/[id]` -> `/admin/collections/{id}` (forward body)
- `DELETE /api/collections/[id]` -> `/admin/collections/{id}`
- `GET /api/collections/[id]/assets` -> `/admin/collections/{id}/assets` (forwards page, limit)
- `POST /api/collections/[id]/assets` -> `/admin/collections/{id}/assets` (forward body: assetId)
- `DELETE /api/collections/[id]/assets/[assetId]` -> `/admin/collections/{id}/assets/{assetId}`

For routes with nested dynamic params (collections/[id]/assets/[assetId]):
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; assetId: string }> }
) {
  const { id, assetId } = await params
  const result = await proxyToBackend(request, `/admin/collections/${id}/assets/${assetId}`, {
    method: 'DELETE',
  })
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else return NextResponse.json(result.data)
  // ... existing mock code ...
}
```

Keep all existing mock collection data and membership logic intact.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>All 4 collection routes have conditional proxy logic with mock fallback</done>
</task>

<task type="auto">
  <name>Task 2: Add proxy logic to cross-cutting routes (activity, search, audit, financials)</name>
  <files>
    src/app/api/activity/route.ts
    src/app/api/search/route.ts
    src/app/api/audit/route.ts
    src/app/api/financials/export/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to the 4 cross-cutting route files.

**Backend paths:**
- `GET /api/activity` -> `/admin/activity` (forwards entityType, entityId, page, limit)
- `GET /api/search` -> `/admin/search` (forwards query param)
- `GET /api/audit` -> `/admin/audit` (forwards any filter params)
- `POST /api/audit` -> `/admin/audit` (forward body for audit log creation)
- `GET /api/financials/export` -> `/admin/financials/export` (forwards any filter params)

**For the search route:** The search endpoint returns results across multiple entity types (users, assets, contributors, payees). In proxy mode, the backend handles the cross-entity search. The response shape adapter will need to match Conductor's SearchResult type.

```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function GET(request: NextRequest) {
  const result = await proxyToBackend(request, '/admin/search')
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else {
    // TODO: Adapt search results to match Conductor's SearchResult[] type
    return NextResponse.json(result.data)
  }
  // ... existing mock search code ...
}
```

**For the financial export route:** This returns CSV-formatted data. In proxy mode, the backend may return the data in a different format. Add a TODO for CSV format adaptation:
```typescript
// TODO: If backend returns raw financial data (JSON), convert to CSV format here
// If backend returns CSV directly, pipe through as-is
```

**For the audit route:** Both GET (read audit log) and POST (write audit entry) need proxy paths. The POST is fire-and-forget in production (audit writes should not block the UI).

Keep all existing mock data generation intact.
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>All 8 collection and cross-cutting routes have conditional proxy logic, completing 100% proxy coverage across all 41 route handlers</done>
</task>

</tasks>

<verification>
1. All 8 files import `proxyToBackend`
2. Collection CRUD and membership routes proxied correctly
3. Activity, search, audit, financial routes proxied correctly
4. Mock data generation unchanged across all files
5. `npm run build` passes
6. All 41 route.ts files in the project now have conditional proxy logic (verify with `grep -r "proxyToBackend" src/app/api/ | wc -l` showing 40+ matches â€” auth/logout excluded)
</verification>

<success_criteria>
- Every non-auth route handler in Conductor has conditional proxy support
- Collections, activity feed, global search, audit log, and financial export all proxied
- Mock mode behavior identical to before
- App builds without errors
- Complete proxy coverage achieved
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-06-SUMMARY.md`
</output>
