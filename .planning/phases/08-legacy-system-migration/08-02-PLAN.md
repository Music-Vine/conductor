---
phase: 08-legacy-system-migration
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/users/route.ts
  - src/app/api/users/[id]/route.ts
  - src/app/api/users/[id]/downloads/route.ts
  - src/app/api/users/[id]/licenses/route.ts
  - src/app/api/users/[id]/refund/route.ts
  - src/app/api/users/[id]/suspend/route.ts
  - src/app/api/users/[id]/unsuspend/route.ts
  - src/app/api/users/[id]/disconnect-oauth/route.ts
  - src/app/api/users/bulk/route.ts
  - src/app/api/users/bulk/ids/route.ts
autonomous: true

must_haves:
  truths:
    - "All user route handlers conditionally proxy to real backend when NEXT_PUBLIC_USE_REAL_API=true"
    - "Existing mock data generation is preserved when NEXT_PUBLIC_USE_REAL_API is false or unset"
    - "User list, detail, downloads, licenses, refund, suspend, unsuspend, OAuth disconnect, and bulk operations all have proxy paths"
  artifacts:
    - path: "src/app/api/users/route.ts"
      provides: "Conditional proxy for user list/create"
      contains: "proxyToBackend"
    - path: "src/app/api/users/[id]/route.ts"
      provides: "Conditional proxy for user detail/update"
      contains: "proxyToBackend"
    - path: "src/app/api/users/bulk/route.ts"
      provides: "Conditional proxy for bulk user operations"
      contains: "proxyToBackend"
  key_links:
    - from: "src/app/api/users/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
---

<objective>
Add conditional BFF proxy logic to all 10 user-domain route handlers, preserving existing mock data generation as the fallback when not using the real API.

Purpose: Enable the users section of Conductor to work against real backend data when the feature flag is enabled, while keeping mock mode for local development.
Output: All user route handlers updated with proxy logic using the shared proxyToBackend helper.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md
@src/lib/api/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proxy logic to user list and detail routes</name>
  <files>
    src/app/api/users/route.ts
    src/app/api/users/[id]/route.ts
    src/app/api/users/[id]/downloads/route.ts
    src/app/api/users/[id]/licenses/route.ts
  </files>
  <action>
For each of these 4 route files, apply the conditional proxy pattern:

1. Import `proxyToBackend` from `@/lib/api/proxy`
2. At the top of each HTTP method handler (GET, POST, PATCH, etc.), add the proxy check BEFORE the mock data generation:

```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function GET(request: NextRequest) {
  // Try real backend first
  const result = await proxyToBackend(request, '/admin/users')
  if (result === null) {
    // Mock mode — fall through to existing mock generation below
  } else if (result instanceof NextResponse) {
    return result // Error response from proxy
  } else {
    // Success — adapt backend response shape to Conductor types
    // TODO: Implement adaptUsersResponse when real backend shape is known
    return NextResponse.json(result.data)
  }

  // === Existing mock data generation (unchanged) ===
  // ... all existing code stays here ...
}
```

**Backend paths for each route:**
- `GET /api/users` -> `/admin/users` (forwards query params: query, status, tier, platform, page, limit)
- `GET /api/users/[id]` -> `/admin/users/{id}` (extract id from URL params)
- `PATCH /api/users/[id]` -> `/admin/users/{id}` (forward body)
- `GET /api/users/[id]/downloads` -> `/admin/users/{id}/downloads`
- `GET /api/users/[id]/licenses` -> `/admin/users/{id}/licenses`

**Important:** Keep ALL existing mock generation code intact. The proxy check is an early return — if it returns null (mock mode), execution falls through to the existing code unchanged.

**For routes with URL params** (like `[id]`): Extract the id from the route params and construct the backend path dynamically:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const result = await proxyToBackend(request, `/admin/users/${id}`)
  // ... proxy handling ...

  // Existing mock code below
}
```

Add a `// TODO: adapt response shape` comment in each proxy success path — the actual adapter will be written when the real backend response shape is known.
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>Users list, detail, downloads, and licenses routes all have conditional proxy logic with mock fallback preserved</done>
</task>

<task type="auto">
  <name>Task 2: Add proxy logic to user action and bulk routes</name>
  <files>
    src/app/api/users/[id]/refund/route.ts
    src/app/api/users/[id]/suspend/route.ts
    src/app/api/users/[id]/unsuspend/route.ts
    src/app/api/users/[id]/disconnect-oauth/route.ts
    src/app/api/users/bulk/route.ts
    src/app/api/users/bulk/ids/route.ts
  </files>
  <action>
Apply the same conditional proxy pattern to the remaining 6 user route files.

**Backend paths:**
- `POST /api/users/[id]/refund` -> `/admin/users/{id}/refund` (forward body with amount, reason)
- `POST /api/users/[id]/suspend` -> `/admin/users/{id}/suspend` (forward body)
- `POST /api/users/[id]/unsuspend` -> `/admin/users/{id}/unsuspend` (forward body)
- `POST /api/users/[id]/disconnect-oauth` -> `/admin/users/{id}/disconnect-oauth` (forward body with provider)
- `POST /api/users/bulk` -> `/admin/users/bulk` (forward body with action, userIds)
- `GET /api/users/bulk/ids` -> `/admin/users/bulk/ids` (forward query params for filtered ID fetching)

**For action routes (refund, suspend, unsuspend, disconnect-oauth):**
These are POST endpoints that forward a JSON body. Use the body option in proxyToBackend:
```typescript
const body = await request.json()
const result = await proxyToBackend(request, `/admin/users/${id}/refund`, { method: 'POST', body })
```

**For bulk routes:**
The bulk operation route (`POST /api/users/bulk`) uses SSE streaming for progress. When in proxy mode, the real backend should also return SSE. Forward the request and pipe the response stream back:
```typescript
// For SSE bulk operations in proxy mode, forward the stream directly
if (result !== null && !(result instanceof NextResponse)) {
  // If the backend returns a streaming response, pipe it through
  // For now, return the data directly — SSE streaming will need
  // adjustment when the real backend SSE format is known
  return NextResponse.json(result.data)
}
```

Add `// TODO: SSE stream forwarding for bulk operations` comment in the bulk route proxy path.

Keep all existing mock data generation and SSE streaming code intact as fallback.
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>All 10 user domain routes have conditional proxy logic, mock fallback preserved, bulk SSE noted for future adaptation</done>
</task>

</tasks>

<verification>
1. All 10 files in `src/app/api/users/` import `proxyToBackend`
2. Each route handler checks the feature flag before mock data generation
3. Mock data generation code is unchanged (no functional regressions)
4. `npm run build` passes
5. App still works in mock mode (default behavior unchanged)
</verification>

<success_criteria>
- All user-domain route handlers support conditional proxying
- Mock mode (default) behavior is identical to before
- Backend paths are documented in code comments
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-02-SUMMARY.md`
</output>
