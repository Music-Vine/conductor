---
phase: 08-legacy-system-migration
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/assets/presigned-url/route.ts
  - src/app/api/assets/multipart/create/route.ts
  - src/app/api/assets/multipart/sign-part/route.ts
  - src/app/api/assets/multipart/complete/route.ts
  - src/app/api/assets/multipart/abort/route.ts
  - src/app/api/assets/check-duplicates/route.ts
  - src/app/api/assets/bulk/route.ts
  - src/app/api/assets/bulk/ids/route.ts
autonomous: true

must_haves:
  truths:
    - "Asset upload routes (presigned URL, multipart) conditionally proxy to real backend"
    - "Asset bulk operation routes conditionally proxy to real backend"
    - "Duplicate check route conditionally proxies to real backend"
    - "Existing mock upload simulation and bulk SSE streaming are preserved as fallback"
  artifacts:
    - path: "src/app/api/assets/presigned-url/route.ts"
      provides: "Conditional proxy for S3 presigned URL generation"
      contains: "proxyToBackend"
    - path: "src/app/api/assets/bulk/route.ts"
      provides: "Conditional proxy for bulk asset operations"
      contains: "proxyToBackend"
  key_links:
    - from: "src/app/api/assets/presigned-url/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
---

<objective>
Add conditional BFF proxy logic to the 8 asset upload infrastructure and bulk operation route handlers.

Purpose: Enable asset upload (S3 presigned URLs, multipart), duplicate checking, and bulk operations to work against the real backend when the feature flag is enabled.
Output: 8 asset route handlers updated with proxy logic.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md
@src/lib/api/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proxy logic to asset upload infrastructure routes</name>
  <files>
    src/app/api/assets/presigned-url/route.ts
    src/app/api/assets/multipart/create/route.ts
    src/app/api/assets/multipart/sign-part/route.ts
    src/app/api/assets/multipart/complete/route.ts
    src/app/api/assets/multipart/abort/route.ts
    src/app/api/assets/check-duplicates/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to the 6 upload-related route files.

**Backend paths:**
- `POST /api/assets/presigned-url` -> `/admin/assets/presigned-url` (forward body: filename, contentType, fileSize)
- `POST /api/assets/multipart/create` -> `/admin/assets/multipart/create` (forward body: filename, contentType, fileSize)
- `POST /api/assets/multipart/sign-part` -> `/admin/assets/multipart/sign-part` (forward body: uploadId, key, partNumber)
- `POST /api/assets/multipart/complete` -> `/admin/assets/multipart/complete` (forward body: uploadId, key, parts)
- `POST /api/assets/multipart/abort` -> `/admin/assets/multipart/abort` (forward body: uploadId, key)
- `POST /api/assets/check-duplicates` -> `/admin/assets/check-duplicates` (forward body: hashes)

**Important for upload routes:** These routes interact with S3 in production. The real backend handles S3 presigned URL generation and multipart orchestration. In proxy mode, Conductor just forwards the request and returns the backend's response (which contains the real S3 URLs).

**For sign-part route:** Use a shorter timeout override since this is called frequently during upload: `{ method: 'POST', body, timeout: 5_000 }`

Pattern:
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function POST(request: NextRequest) {
  const body = await request.json()
  const result = await proxyToBackend(request, '/admin/assets/presigned-url', {
    method: 'POST',
    body,
  })
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else return NextResponse.json(result.data)

  // ... existing mock code (use `body` variable) ...
}
```

Adjust existing mock code to use the pre-parsed `body` variable instead of re-calling `request.json()`.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>All 6 upload infrastructure routes have conditional proxy logic with mock fallback</done>
</task>

<task type="auto">
  <name>Task 2: Add proxy logic to asset bulk operation routes</name>
  <files>
    src/app/api/assets/bulk/route.ts
    src/app/api/assets/bulk/ids/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to the 2 bulk asset route files.

**Backend paths:**
- `POST /api/assets/bulk` -> `/admin/assets/bulk` (forward body with action, assetIds)
- `GET /api/assets/bulk/ids` -> `/admin/assets/bulk/ids` (forward query params for filtered ID list)

**For the bulk operation route (POST):** This route uses SSE (Server-Sent Events) streaming for progress updates. In proxy mode, the real backend should also return an SSE stream. For now, add the proxy check with a TODO for SSE stream forwarding:

```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function POST(request: NextRequest) {
  const body = await request.json()
  const result = await proxyToBackend(request, '/admin/assets/bulk', {
    method: 'POST',
    body,
  })
  if (result === null) { /* fall through to mock SSE streaming */ }
  else if (result instanceof NextResponse) return result
  else {
    // TODO: When real backend returns SSE stream, pipe it through directly
    // For now, return the data as JSON (non-streaming)
    return NextResponse.json(result.data)
  }

  // ... existing mock SSE streaming code ...
}
```

**For the bulk IDs route (GET):** This is a simple GET that returns a list of IDs. Standard proxy pattern:
```typescript
const result = await proxyToBackend(request, '/admin/assets/bulk/ids')
if (result === null) { /* fall through to mock */ }
else if (result instanceof NextResponse) return result
else return NextResponse.json(result.data)
```

Keep all existing mock SSE streaming and mock ID generation code intact.
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>All 8 asset upload and bulk routes have conditional proxy logic, mock fallback preserved, SSE streaming noted for future adaptation</done>
</task>

</tasks>

<verification>
1. All 8 files import `proxyToBackend`
2. Upload routes forward body correctly to backend paths
3. Bulk routes have TODO comments for SSE stream forwarding
4. Mock mode behavior unchanged
5. `npm run build` passes
</verification>

<success_criteria>
- Asset upload (presigned URL, multipart CRUD, duplicate check) routes support conditional proxying
- Bulk asset routes support conditional proxying with SSE streaming noted
- Mock mode behavior is identical to before
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-04-SUMMARY.md`
</output>
