---
phase: 08-legacy-system-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/proxy.ts
  - .env.example
  - .env.local
  - src/proxy.ts
autonomous: true

must_haves:
  truths:
    - "A shared proxy helper function exists that all route handlers can use for backend forwarding"
    - "Environment variables for backend integration are documented and typed"
    - "middleware.ts has been renamed to proxy.ts per Next.js 16 convention"
  artifacts:
    - path: "src/lib/api/proxy.ts"
      provides: "Shared proxyToBackend helper for route handlers"
      exports: ["proxyToBackend"]
    - path: ".env.example"
      provides: "Documented env var template for backend integration"
      contains: "BACKEND_API_BASE_URL"
    - path: "src/proxy.ts"
      provides: "Renamed middleware file (Next.js 16 convention)"
      contains: "export async function proxy"
  key_links:
    - from: "src/lib/api/proxy.ts"
      to: "process.env.BACKEND_API_BASE_URL"
      via: "environment variable read"
      pattern: "process\\.env\\.BACKEND_API_BASE_URL"
    - from: "src/lib/api/proxy.ts"
      to: "process.env.NEXT_PUBLIC_USE_REAL_API"
      via: "feature flag check"
      pattern: "NEXT_PUBLIC_USE_REAL_API"
---

<objective>
Create the shared proxy infrastructure that all route handlers will use to conditionally forward requests to the real backend API, and run the Next.js 16 middleware-to-proxy codemod.

Purpose: Establish the foundation pattern (proxyToBackend helper, env vars, codemod) that all subsequent route handler integration plans depend on.
Output: `src/lib/api/proxy.ts` helper, updated `.env.example`, migrated `src/proxy.ts`.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-CONTEXT.md
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared proxyToBackend helper</name>
  <files>src/lib/api/proxy.ts</files>
  <action>
Create `src/lib/api/proxy.ts` with a reusable `proxyToBackend` function that all route handlers will use. The function should:

1. Accept parameters: `request: NextRequest`, `backendPath: string`, and optional `options: { method?: string, body?: unknown, timeout?: number }`
2. Check `process.env.NEXT_PUBLIC_USE_REAL_API === 'true'` — if false, return `null` (caller falls through to mock data)
3. Check `process.env.BACKEND_API_BASE_URL` exists — if missing and real API enabled, throw descriptive error
4. Construct backend URL from `BACKEND_API_BASE_URL + backendPath`
5. Forward query params from the incoming request to the backend URL
6. Forward these headers to the backend:
   - `Authorization: Bearer ${process.env.BACKEND_API_SECRET}`
   - `X-Platform: ${request.headers.get('x-platform') ?? 'music-vine'}`
   - `X-Conductor-User: ${request.headers.get('x-user-id') ?? ''}`
   - `Content-Type: application/json` (when body present)
7. Use `signal: AbortSignal.timeout(options.timeout ?? 10_000)` for timeouts
8. On fetch error (network, timeout), return `NextResponse.json({ code: 'BACKEND_UNAVAILABLE', message: 'Backend request failed' }, { status: 502 })`
9. On non-ok backend response, log the error and return `NextResponse.json({ code: 'BACKEND_ERROR', message: 'Backend returned error' }, { status: backendResponse.status })`
10. On success, return `backendResponse.json()` as raw data (let caller adapt the shape)

Also export a `USE_REAL_API` constant: `process.env.NEXT_PUBLIC_USE_REAL_API === 'true'`

Return type should be `{ data: unknown } | NextResponse` — where `NextResponse` means an error occurred, and `{ data: unknown }` means success with raw backend data.

Include JSDoc comments explaining the pattern and how callers should use it:
```typescript
// Usage in route handler:
// const result = await proxyToBackend(request, '/admin/users')
// if (result === null) return NextResponse.json(generateMockData()) // mock mode
// if (result instanceof NextResponse) return result // error response
// const adapted = adaptResponse(result.data) // success — adapt shape
// return NextResponse.json(adapted)
```
  </action>
  <verify>TypeScript compiles: `cd /Users/sambeevors/Code/conductor && npx tsc --noEmit src/lib/api/proxy.ts` (or check via full build)</verify>
  <done>proxyToBackend function exported from src/lib/api/proxy.ts, handles all proxy concerns (auth headers, timeout, error handling, feature flag check)</done>
</task>

<task type="auto">
  <name>Task 2: Add environment variables and run middleware codemod</name>
  <files>.env.example, .env.local, src/proxy.ts</files>
  <action>
1. **Update `.env.example`** — add these new entries (preserving existing entries):
```
# Backend API Integration (Phase 8)
# Set NEXT_PUBLIC_USE_REAL_API=true to switch from mock data to real backend
NEXT_PUBLIC_USE_REAL_API=false
BACKEND_API_BASE_URL=https://api.internal.example.com
BACKEND_API_SECRET=your-backend-api-secret-here
```

2. **Update `.env.local`** (if it exists) — add the same entries with `false` default so local dev continues using mocks. If `.env.local` doesn't exist, create it with all entries from `.env.example`.

3. **Run the Next.js 16 middleware-to-proxy codemod:**
```bash
npx @next/codemod@canary middleware-to-proxy .
```
This renames `src/middleware.ts` to `src/proxy.ts` and renames the exported function from `middleware` to `proxy`. Verify the file was renamed and the export signature changed.

4. **After codemod, verify:**
   - `src/middleware.ts` no longer exists
   - `src/proxy.ts` exists and exports `async function proxy(request: NextRequest)`
   - The `config` export with matcher is preserved
   - All auth logic (JWT verification, session validation, header forwarding) is unchanged

5. **If the codemod fails or is unavailable:** Do the rename manually:
   - Rename `src/middleware.ts` to `src/proxy.ts`
   - Change `export async function middleware(` to `export async function proxy(`
   - Everything else stays the same

6. Verify the app still builds: `npm run build` (or at minimum `npx tsc --noEmit`)
  </action>
  <verify>`ls src/proxy.ts` exists, `ls src/middleware.ts` does NOT exist, `grep "export async function proxy" src/proxy.ts` succeeds, `npm run build` succeeds</verify>
  <done>Environment variables documented in .env.example, middleware.ts successfully migrated to proxy.ts, app builds without errors</done>
</task>

</tasks>

<verification>
1. `src/lib/api/proxy.ts` exports `proxyToBackend` and `USE_REAL_API`
2. `.env.example` contains `NEXT_PUBLIC_USE_REAL_API`, `BACKEND_API_BASE_URL`, `BACKEND_API_SECRET`
3. `src/proxy.ts` exists with `export async function proxy`
4. `src/middleware.ts` does NOT exist
5. `npm run build` passes
</verification>

<success_criteria>
- Shared proxy helper is ready for all route handlers to import
- Environment variables are documented and defaulted to mock mode
- middleware.ts is migrated to proxy.ts per Next.js 16
- App builds and runs in mock mode without changes to existing behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md`
</output>
