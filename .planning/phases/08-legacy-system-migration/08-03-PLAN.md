---
phase: 08-legacy-system-migration
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/api/assets/route.ts
  - src/app/api/assets/[id]/route.ts
  - src/app/api/assets/[id]/workflow/route.ts
  - src/app/api/assets/[id]/activity/route.ts
  - src/app/api/assets/[id]/approve/route.ts
  - src/app/api/assets/[id]/reject/route.ts
  - src/app/api/assets/[id]/unpublish/route.ts
autonomous: true

must_haves:
  truths:
    - "Asset list, detail, workflow, activity, approve, reject, and unpublish routes conditionally proxy to real backend"
    - "Existing mock data generation is preserved when NEXT_PUBLIC_USE_REAL_API is false"
    - "Workflow actions (approve, reject, unpublish) forward request bodies to backend"
  artifacts:
    - path: "src/app/api/assets/route.ts"
      provides: "Conditional proxy for asset list/create"
      contains: "proxyToBackend"
    - path: "src/app/api/assets/[id]/route.ts"
      provides: "Conditional proxy for asset detail/update"
      contains: "proxyToBackend"
    - path: "src/app/api/assets/[id]/workflow/route.ts"
      provides: "Conditional proxy for workflow state"
      contains: "proxyToBackend"
  key_links:
    - from: "src/app/api/assets/route.ts"
      to: "src/lib/api/proxy.ts"
      via: "import proxyToBackend"
      pattern: "import.*proxyToBackend.*from.*proxy"
---

<objective>
Add conditional BFF proxy logic to the 7 core asset route handlers (list, detail, workflow, activity, and workflow actions), preserving existing mock data generation as fallback.

Purpose: Enable the core asset management screens and workflow actions in Conductor to work against real backend data when the feature flag is enabled.
Output: 7 asset route handlers updated with proxy logic.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-legacy-system-migration/08-RESEARCH.md
@.planning/phases/08-legacy-system-migration/08-01-SUMMARY.md
@src/lib/api/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add proxy logic to asset list, detail, workflow, and activity routes</name>
  <files>
    src/app/api/assets/route.ts
    src/app/api/assets/[id]/route.ts
    src/app/api/assets/[id]/workflow/route.ts
    src/app/api/assets/[id]/activity/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to these 4 route files. Import `proxyToBackend` from `@/lib/api/proxy`.

**Backend paths:**
- `GET /api/assets` -> `/admin/assets` (forwards query params: query, type, status, platform, genre, page, limit)
- `POST /api/assets` -> `/admin/assets` (forward body with type, title, contributorId, fileKey, metadata)
- `GET /api/assets/[id]` -> `/admin/assets/{id}`
- `PATCH /api/assets/[id]` -> `/admin/assets/{id}` (forward body with updated fields)
- `GET /api/assets/[id]/workflow` -> `/admin/assets/{id}/workflow`
- `GET /api/assets/[id]/activity` -> `/admin/assets/{id}/activity` (forwards page, limit params)

For each handler, add the proxy check at the top:
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function GET(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params
  const result = await proxyToBackend(request, `/admin/assets/${id}`)
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else {
    // TODO: adapt response shape when real backend format is known
    return NextResponse.json(result.data)
  }
  // ... existing mock code unchanged ...
}
```

For `assets/route.ts` which has both GET and POST:
- GET: proxy to `/admin/assets` with query params forwarded
- POST: proxy to `/admin/assets` with body forwarded via `{ method: 'POST', body }`

Keep all existing mock data generation functions (generateMockAssets, etc.) intact.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>Asset list, detail, workflow, and activity routes have conditional proxy logic with mock fallback</done>
</task>

<task type="auto">
  <name>Task 2: Add proxy logic to asset workflow action routes</name>
  <files>
    src/app/api/assets/[id]/approve/route.ts
    src/app/api/assets/[id]/reject/route.ts
    src/app/api/assets/[id]/unpublish/route.ts
  </files>
  <action>
Apply the conditional proxy pattern to the 3 workflow action routes.

**Backend paths:**
- `POST /api/assets/[id]/approve` -> `/admin/assets/{id}/approve` (forward body with optional comments, stage)
- `POST /api/assets/[id]/reject` -> `/admin/assets/{id}/reject` (forward body with comments â€” required for rejection)
- `POST /api/assets/[id]/unpublish` -> `/admin/assets/{id}/unpublish` (forward body)

Pattern for POST action routes:
```typescript
import { proxyToBackend } from '@/lib/api/proxy'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const body = await request.clone().json() // clone to allow re-read in mock path
  const result = await proxyToBackend(request, `/admin/assets/${id}/approve`, {
    method: 'POST',
    body,
  })
  if (result === null) { /* fall through to mock */ }
  else if (result instanceof NextResponse) return result
  else return NextResponse.json(result.data)

  // ... existing mock code (re-parse body from request) ...
}
```

**Important for request body handling:** Since `request.json()` can only be called once, use `request.clone().json()` in the proxy path so the mock path can still read the body. Alternatively, read the body once into a variable and pass it to both paths.

Better pattern (read once):
```typescript
const body = await request.json()
const result = await proxyToBackend(request, `/admin/assets/${id}/approve`, {
  method: 'POST',
  body,
})
if (result === null) { /* use `body` variable in mock logic below */ }
// ... adjust existing mock code to use the `body` variable instead of re-calling request.json()
```

Keep all existing mock validation logic (e.g., rejection requires comments) intact in the mock path.
  </action>
  <verify>`npx tsc --noEmit` passes, `npm run build` succeeds</verify>
  <done>All 7 core asset route handlers have conditional proxy logic, mock fallback preserved</done>
</task>

</tasks>

<verification>
1. All 7 files import `proxyToBackend` from `@/lib/api/proxy`
2. Each route handler checks the feature flag before mock data generation
3. Mock data generation code is unchanged
4. `npm run build` passes
</verification>

<success_criteria>
- Core asset routes (list, detail, workflow, activity, approve, reject, unpublish) all support conditional proxying
- Mock mode behavior is identical to before
- App builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-legacy-system-migration/08-03-SUMMARY.md`
</output>
