---
phase: 04-catalog-management
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-04", "04-05"]
files_modified:
  - src/hooks/useUploader.tsx
  - src/hooks/useDuplicateCheck.tsx
  - src/components/upload/FileDropzone.tsx
  - src/components/upload/FileUploadList.tsx
  - src/components/upload/index.ts
autonomous: true

must_haves:
  truths:
    - "Uppy integration handles file selection and progress"
    - "Dropzone supports drag-drop and click-to-select"
    - "Per-file progress displayed in upload list"
    - "Duplicate check runs before upload starts"
  artifacts:
    - path: "src/hooks/useUploader.tsx"
      provides: "Uppy file upload hook"
      exports: ["useUploader"]
    - path: "src/components/upload/FileDropzone.tsx"
      provides: "Drag-drop file selection"
      exports: ["FileDropzone"]
    - path: "src/components/upload/FileUploadList.tsx"
      provides: "Per-file upload progress"
      exports: ["FileUploadList"]
  key_links:
    - from: "src/hooks/useUploader.tsx"
      to: "@uppy/core"
      via: "Uppy instance management"
      pattern: "import Uppy from '@uppy/core'"
    - from: "src/components/upload/FileDropzone.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "import.*useDropzone.*from 'react-dropzone'"
---

<objective>
Build the file upload infrastructure with Uppy integration and UI components.

Purpose: Enable multi-file uploads with progress tracking, validation, and duplicate detection.
Output: Reusable upload hooks and components for the upload page.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog-management/CONTEXT.md
@.planning/phases/04-catalog-management/04-RESEARCH.md
@.planning/phases/04-catalog-management/04-02-SUMMARY.md
@.planning/phases/04-catalog-management/04-04-SUMMARY.md
@.planning/phases/04-catalog-management/04-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Uppy upload hook</name>
  <files>src/hooks/useUploader.tsx</files>
  <action>
Create Uppy integration hook based on RESEARCH Complete Upload Hook pattern:

```typescript
'use client'

import Uppy from '@uppy/core'
import AwsS3 from '@uppy/aws-s3'
import { useState, useEffect, useCallback, useMemo } from 'react'
import type { AssetType } from '@/types/asset'
import { getAllowedTypes } from '@/lib/upload'

export interface UploadFile {
  id: string
  name: string
  size: number
  type: string
  progress: number
  status: 'pending' | 'validating' | 'uploading' | 'processing' | 'complete' | 'error'
  error?: string
  fileKey?: string
}

interface UseUploaderOptions {
  assetType: AssetType
  onFileComplete?: (file: UploadFile) => void
  onAllComplete?: (files: UploadFile[]) => void
  onError?: (file: UploadFile, error: Error) => void
}

export function useUploader(options: UseUploaderOptions) {
  const { assetType, onFileComplete, onAllComplete, onError } = options
  const [files, setFiles] = useState<UploadFile[]>([])

  // Get allowed file extensions for this asset type
  const allowedTypes = useMemo(() => getAllowedTypes(assetType), [assetType])

  // Create Uppy instance
  const [uppy] = useState(() => {
    const instance = new Uppy({
      restrictions: {
        maxFileSize: 5 * 1024 * 1024 * 1024, // 5GB
        allowedFileTypes: allowedTypes,
      },
      autoProceed: false, // Manual upload trigger
    })

    // Configure S3 plugin with mock endpoints
    instance.use(AwsS3, {
      shouldUseMultipart: (file) => file.size > 100 * 1024 * 1024, // >100MB

      // Single-part upload
      async getUploadParameters(file) {
        const response = await fetch('/api/assets/presigned-url', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filename: file.name,
            contentType: file.type,
            size: file.size,
          }),
        })
        if (!response.ok) throw new Error('Failed to get upload URL')
        const { url, key } = await response.json()
        return { method: 'PUT', url, headers: {}, fields: { key } }
      },

      // Multipart upload handlers
      async createMultipartUpload(file) {
        const response = await fetch('/api/assets/multipart/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: file.name, contentType: file.type }),
        })
        if (!response.ok) throw new Error('Failed to create multipart upload')
        return response.json()
      },

      async signPart(file, { key, uploadId, partNumber }) {
        const response = await fetch('/api/assets/multipart/sign-part', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key, uploadId, partNumber }),
        })
        if (!response.ok) throw new Error('Failed to sign part')
        return response.json()
      },

      async completeMultipartUpload(file, { key, uploadId, parts }) {
        await fetch('/api/assets/multipart/complete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key, uploadId, parts }),
        })
        return {}
      },

      async abortMultipartUpload(file, { key, uploadId }) {
        await fetch('/api/assets/multipart/abort', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key, uploadId }),
        })
      },
    })

    return instance
  })

  // Setup event handlers
  useEffect(() => {
    const handleFileAdded = (file: any) => {
      setFiles(prev => [...prev, {
        id: file.id,
        name: file.name,
        size: file.size,
        type: file.type,
        progress: 0,
        status: 'pending',
      }])
    }

    const handleProgress = (file: any, progress: any) => {
      const percent = Math.round((progress.bytesUploaded / progress.bytesTotal) * 95) // Reserve 5% for finalization
      setFiles(prev => prev.map(f =>
        f.id === file.id ? { ...f, progress: percent, status: 'uploading' } : f
      ))
    }

    const handleUploadSuccess = (file: any, response: any) => {
      const fileKey = file.meta?.key || response?.key
      setFiles(prev => prev.map(f =>
        f.id === file.id ? { ...f, progress: 100, status: 'complete', fileKey } : f
      ))
      const uploadFile = files.find(f => f.id === file.id)
      if (uploadFile) onFileComplete?.({ ...uploadFile, status: 'complete', progress: 100, fileKey })
    }

    const handleUploadError = (file: any, error: any) => {
      setFiles(prev => prev.map(f =>
        f.id === file.id ? { ...f, status: 'error', error: error?.message || 'Upload failed' } : f
      ))
      const uploadFile = files.find(f => f.id === file.id)
      if (uploadFile) onError?.({ ...uploadFile, status: 'error' }, error)
    }

    const handleComplete = (result: any) => {
      if (result.successful.length > 0) {
        onAllComplete?.(files.filter(f => f.status === 'complete'))
      }
    }

    uppy.on('file-added', handleFileAdded)
    uppy.on('upload-progress', handleProgress)
    uppy.on('upload-success', handleUploadSuccess)
    uppy.on('upload-error', handleUploadError)
    uppy.on('complete', handleComplete)

    return () => {
      uppy.off('file-added', handleFileAdded)
      uppy.off('upload-progress', handleProgress)
      uppy.off('upload-success', handleUploadSuccess)
      uppy.off('upload-error', handleUploadError)
      uppy.off('complete', handleComplete)
    }
  }, [uppy, files, onFileComplete, onAllComplete, onError])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      uppy.close()
    }
  }, [uppy])

  const addFiles = useCallback((newFiles: File[]) => {
    newFiles.forEach(file => {
      try {
        uppy.addFile({
          name: file.name,
          type: file.type,
          data: file,
        })
      } catch (e) {
        // Uppy throws if file doesn't meet restrictions
        console.error('Failed to add file:', e)
      }
    })
  }, [uppy])

  const removeFile = useCallback((fileId: string) => {
    uppy.removeFile(fileId)
    setFiles(prev => prev.filter(f => f.id !== fileId))
  }, [uppy])

  const startUpload = useCallback(() => {
    // Mark all pending files as uploading
    setFiles(prev => prev.map(f =>
      f.status === 'pending' ? { ...f, status: 'uploading' } : f
    ))
    uppy.upload()
  }, [uppy])

  const retryFile = useCallback((fileId: string) => {
    setFiles(prev => prev.map(f =>
      f.id === fileId ? { ...f, status: 'pending', error: undefined, progress: 0 } : f
    ))
    uppy.retryUpload(fileId)
  }, [uppy])

  const clearFiles = useCallback(() => {
    uppy.cancelAll()
    setFiles([])
  }, [uppy])

  return {
    files,
    addFiles,
    removeFile,
    startUpload,
    retryFile,
    clearFiles,
    isUploading: files.some(f => f.status === 'uploading'),
    hasErrors: files.some(f => f.status === 'error'),
    allComplete: files.length > 0 && files.every(f => f.status === 'complete'),
  }
}
```
  </action>
  <verify>Hook compiles without TypeScript errors</verify>
  <done>Uppy hook manages complete upload lifecycle with S3 multipart support</done>
</task>

<task type="auto">
  <name>Task 2: Create duplicate check hook and dropzone component</name>
  <files>src/hooks/useDuplicateCheck.tsx, src/components/upload/FileDropzone.tsx</files>
  <action>
Create src/hooks/useDuplicateCheck.tsx:
```typescript
'use client'

import { useState, useCallback } from 'react'
import { hashFile } from '@/lib/upload'

interface DuplicateResult {
  isDuplicate: boolean
  existingAssetId?: string
  existingAssetTitle?: string
}

export function useDuplicateCheck() {
  const [checking, setChecking] = useState(false)

  const checkDuplicate = useCallback(async (file: File): Promise<DuplicateResult> => {
    setChecking(true)
    try {
      const hash = await hashFile(file)
      const response = await fetch('/api/assets/check-duplicates', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hash, filename: file.name }),
      })
      if (!response.ok) throw new Error('Duplicate check failed')
      return response.json()
    } finally {
      setChecking(false)
    }
  }, [])

  return { checkDuplicate, checking }
}
```

Create src/components/upload/FileDropzone.tsx:
```typescript
'use client'

import { useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import type { AssetType } from '@/types/asset'
import { getAllowedTypes } from '@/lib/upload'

interface FileDropzoneProps {
  assetType: AssetType
  onFilesSelected: (files: File[]) => void
  disabled?: boolean
  className?: string
}

export function FileDropzone({ assetType, onFilesSelected, disabled, className }: FileDropzoneProps) {
  const allowedTypes = getAllowedTypes(assetType)

  const onDrop = useCallback((acceptedFiles: File[]) => {
    onFilesSelected(acceptedFiles)
  }, [onFilesSelected])

  const { getRootProps, getInputProps, isDragActive, isDragReject } = useDropzone({
    onDrop,
    disabled,
    accept: Object.fromEntries(
      allowedTypes.map(ext => {
        const mimeMap: Record<string, string> = {
          '.mp3': 'audio/mpeg',
          '.wav': 'audio/wav',
          '.flac': 'audio/flac',
          '.aiff': 'audio/aiff',
          '.mp4': 'video/mp4',
          '.mov': 'video/quicktime',
          '.cube': 'application/octet-stream',
          '.3dl': 'application/octet-stream',
        }
        return [mimeMap[ext] || 'application/octet-stream', [ext]]
      })
    ),
    maxSize: 5 * 1024 * 1024 * 1024, // 5GB
  })

  const assetTypeLabels: Record<AssetType, string> = {
    music: 'music files',
    sfx: 'sound effects',
    'motion-graphics': 'motion graphics',
    lut: 'LUT files',
    'stock-footage': 'stock footage',
  }

  return (
    <div
      {...getRootProps()}
      className={`
        relative rounded-lg border-2 border-dashed p-8 text-center transition-colors cursor-pointer
        ${isDragActive && !isDragReject ? 'border-platform-primary bg-platform-primary/5' : ''}
        ${isDragReject ? 'border-red-500 bg-red-50' : ''}
        ${!isDragActive && !disabled ? 'border-gray-300 hover:border-gray-400' : ''}
        ${disabled ? 'border-gray-200 bg-gray-50 cursor-not-allowed' : ''}
        ${className || ''}
      `}
    >
      <input {...getInputProps()} />

      <div className="space-y-2">
        <div className="mx-auto h-12 w-12 text-gray-400">
          <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" />
          </svg>
        </div>

        {isDragReject ? (
          <p className="text-red-600 font-medium">Invalid file type</p>
        ) : isDragActive ? (
          <p className="text-platform-primary font-medium">Drop files here...</p>
        ) : (
          <>
            <p className="text-gray-700">
              <span className="font-medium text-platform-primary">Click to upload</span>
              {' '}or drag and drop
            </p>
            <p className="text-sm text-gray-500">
              {assetTypeLabels[assetType]} ({allowedTypes.join(', ')}) up to 5GB
            </p>
          </>
        )}
      </div>
    </div>
  )
}
```
  </action>
  <verify>Components render correctly in browser</verify>
  <done>Dropzone handles drag-drop with visual feedback for valid/invalid files</done>
</task>

<task type="auto">
  <name>Task 3: Create file upload list component</name>
  <files>src/components/upload/FileUploadList.tsx, src/components/upload/index.ts</files>
  <action>
Create src/components/upload/FileUploadList.tsx for per-file progress display:
```typescript
'use client'

import { Button } from '@music-vine/cadence'
import type { UploadFile } from '@/hooks/useUploader'
import { formatFileSize } from '@/lib/upload'

interface FileUploadListProps {
  files: UploadFile[]
  onRemove: (fileId: string) => void
  onRetry: (fileId: string) => void
}

export function FileUploadList({ files, onRemove, onRetry }: FileUploadListProps) {
  if (files.length === 0) return null

  return (
    <div className="space-y-2">
      {files.map(file => (
        <FileUploadItem
          key={file.id}
          file={file}
          onRemove={() => onRemove(file.id)}
          onRetry={() => onRetry(file.id)}
        />
      ))}
    </div>
  )
}

interface FileUploadItemProps {
  file: UploadFile
  onRemove: () => void
  onRetry: () => void
}

function FileUploadItem({ file, onRemove, onRetry }: FileUploadItemProps) {
  const statusColors: Record<UploadFile['status'], string> = {
    pending: 'text-gray-500',
    validating: 'text-blue-500',
    uploading: 'text-blue-600',
    processing: 'text-yellow-600',
    complete: 'text-green-600',
    error: 'text-red-600',
  }

  const statusLabels: Record<UploadFile['status'], string> = {
    pending: 'Pending',
    validating: 'Validating...',
    uploading: 'Uploading...',
    processing: 'Processing...',
    complete: 'Complete',
    error: 'Failed',
  }

  return (
    <div className="flex items-center gap-4 rounded-lg border border-gray-200 bg-white p-4">
      {/* File icon */}
      <div className="flex-shrink-0 h-10 w-10 rounded-lg bg-gray-100 flex items-center justify-center">
        <FileIcon type={file.type} />
      </div>

      {/* File info */}
      <div className="flex-1 min-w-0">
        <p className="text-sm font-medium text-gray-900 truncate">{file.name}</p>
        <p className="text-xs text-gray-500">{formatFileSize(file.size)}</p>

        {/* Progress bar for uploading status */}
        {file.status === 'uploading' && (
          <div className="mt-2">
            <div className="h-1.5 w-full bg-gray-200 rounded-full overflow-hidden">
              <div
                className="h-full bg-platform-primary transition-all duration-300"
                style={{ width: `${file.progress}%` }}
              />
            </div>
            <p className="mt-1 text-xs text-gray-500">{file.progress}%</p>
          </div>
        )}

        {/* Error message */}
        {file.status === 'error' && file.error && (
          <p className="mt-1 text-xs text-red-600">{file.error}</p>
        )}
      </div>

      {/* Status */}
      <div className="flex-shrink-0 text-right">
        <span className={`text-sm font-medium ${statusColors[file.status]}`}>
          {statusLabels[file.status]}
        </span>
      </div>

      {/* Actions */}
      <div className="flex-shrink-0 flex items-center gap-2">
        {file.status === 'error' && (
          <Button variant="subtle" size="small" onClick={onRetry}>
            Retry
          </Button>
        )}
        {(file.status === 'pending' || file.status === 'error') && (
          <button
            onClick={onRemove}
            className="text-gray-400 hover:text-gray-600 p-1"
            aria-label="Remove file"
          >
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        )}
        {file.status === 'complete' && (
          <svg className="h-5 w-5 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        )}
      </div>
    </div>
  )
}

function FileIcon({ type }: { type: string }) {
  const isAudio = type.startsWith('audio/')
  const isVideo = type.startsWith('video/')

  if (isAudio) {
    return (
      <svg className="h-6 w-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
      </svg>
    )
  }

  if (isVideo) {
    return (
      <svg className="h-6 w-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
      </svg>
    )
  }

  return (
    <svg className="h-6 w-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
    </svg>
  )
}
```

Create src/components/upload/index.ts:
```typescript
export * from './FileDropzone'
export * from './FileUploadList'
```
  </action>
  <verify>Components render file list with progress bars</verify>
  <done>Upload list shows per-file progress, status, retry/remove actions</done>
</task>

</tasks>

<verification>
1. useUploader hook can add files and start upload
2. FileDropzone accepts drops and shows visual feedback
3. FileUploadList displays file progress with all states
4. Retry button appears on error state
5. Remove button only appears on pending/error states
</verification>

<success_criteria>
- Uppy events properly update React state
- Dropzone validates file types before accepting
- Progress bar animates smoothly during upload
- Error state shows retry option
- Complete state shows checkmark
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog-management/04-06-SUMMARY.md`
</output>
