---
phase: 04-catalog-management
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/assets/presigned-url/route.ts
  - src/app/api/assets/multipart/create/route.ts
  - src/app/api/assets/multipart/sign-part/route.ts
  - src/app/api/assets/multipart/complete/route.ts
  - src/app/api/assets/multipart/abort/route.ts
  - src/app/api/assets/check-duplicates/route.ts
autonomous: true

must_haves:
  truths:
    - "Presigned URL endpoint returns mock URLs for upload"
    - "Multipart endpoints support chunked upload lifecycle"
    - "Duplicate check endpoint validates file hashes"
  artifacts:
    - path: "src/app/api/assets/presigned-url/route.ts"
      provides: "Single-part presigned URL generation"
      exports: ["POST"]
    - path: "src/app/api/assets/multipart/create/route.ts"
      provides: "Multipart upload initiation"
      exports: ["POST"]
    - path: "src/app/api/assets/check-duplicates/route.ts"
      provides: "Duplicate file detection"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/assets/presigned-url/route.ts"
      to: "Uppy @uppy/aws-s3 plugin"
      via: "getUploadParameters callback"
      pattern: "presigned-url"
---

<objective>
Create mock upload infrastructure endpoints for S3 presigned URLs and multipart uploads.

Purpose: Enable Uppy integration with mock endpoints that simulate real S3 upload flow.
Output: Complete mock upload API supporting both single-part and multipart uploads.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog-management/CONTEXT.md
@.planning/phases/04-catalog-management/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create single-part presigned URL endpoint</name>
  <files>src/app/api/assets/presigned-url/route.ts</files>
  <action>
Create POST handler for presigned URL generation:

POST /api/assets/presigned-url:
- Accept: { filename: string, contentType: string, size: number }
- Validate file extension against allowed types per CONTEXT:
  - music: .mp3, .wav, .flac, .aiff
  - sfx: .mp3, .wav
  - motion-graphics: .mp4, .mov
  - lut: .cube, .3dl
  - stock-footage: .mp4, .mov
- Return 400 if invalid file type
- Generate mock response:
  ```json
  {
    "url": "https://mock-s3-bucket.s3.amazonaws.com/uploads/uuid/filename?X-Amz-Signature=mock...",
    "key": "uploads/{uuid}/{filename}",
    "fields": {}
  }
  ```
- The mock URL is for frontend simulation - real uploads won't work but Uppy will recognize the response format
- Add 50-100ms latency to simulate network

Note: This is for files under 100MB (Uppy's default multipart threshold).
  </action>
  <verify>curl -X POST localhost:3000/api/assets/presigned-url -d '{"filename":"test.mp3","contentType":"audio/mpeg","size":5000000}' returns mock URL</verify>
  <done>Presigned URL endpoint returns properly formatted response for Uppy</done>
</task>

<task type="auto">
  <name>Task 2: Create multipart upload lifecycle endpoints</name>
  <files>src/app/api/assets/multipart/create/route.ts, src/app/api/assets/multipart/sign-part/route.ts, src/app/api/assets/multipart/complete/route.ts, src/app/api/assets/multipart/abort/route.ts</files>
  <action>
Create multipart upload endpoints per RESEARCH pattern:

POST /api/assets/multipart/create:
- Accept: { filename: string, contentType: string }
- Validate file type (same as presigned-url)
- Return mock: { uploadId: "mock-upload-{uuid}", key: "uploads/{uuid}/{filename}" }
- Add 50ms latency

POST /api/assets/multipart/sign-part:
- Accept: { key: string, uploadId: string, partNumber: number }
- Return mock: { url: "https://mock-s3-bucket.s3.amazonaws.com/{key}?partNumber={partNumber}&uploadId={uploadId}&X-Amz-Signature=mock..." }
- Validate partNumber is 1-10000
- Add 30ms latency (called frequently)

POST /api/assets/multipart/complete:
- Accept: { key: string, uploadId: string, parts: Array<{ partNumber: number, etag: string }> }
- Validate parts array is not empty
- Return mock: { location: "https://mock-s3-bucket.s3.amazonaws.com/{key}" }
- This is where backend would assemble multipart upload
- Add 100ms latency

POST /api/assets/multipart/abort:
- Accept: { key: string, uploadId: string }
- Return 200 with empty body
- This is called when upload is cancelled
- Add 50ms latency

All endpoints should log to console for debugging: `console.log('[Mock S3] Multipart create:', key)`
  </action>
  <verify>Each endpoint responds with correct format when called with valid parameters</verify>
  <done>Full multipart upload lifecycle supported with mock responses</done>
</task>

<task type="auto">
  <name>Task 3: Create duplicate check endpoint</name>
  <files>src/app/api/assets/check-duplicates/route.ts</files>
  <action>
Create POST handler for file hash duplicate detection:

POST /api/assets/check-duplicates:
- Accept: { hash: string, filename: string }
- hash is SHA-256 hex string from client-side Web Crypto
- Simulate duplicate detection:
  - Store a set of "known hashes" (mock: use a few hardcoded hashes)
  - If hash matches known: return { isDuplicate: true, existingAssetId: "mock-existing-id", existingAssetTitle: "Existing Asset Name" }
  - If no match: return { isDuplicate: false }
- For testing, make hashes ending in "0000" be "duplicates"
- Add 100-200ms latency (simulates database lookup)

This enables the frontend to show "File already exists" warning before upload starts.
  </action>
  <verify>curl -X POST localhost:3000/api/assets/check-duplicates -d '{"hash":"abc123","filename":"test.mp3"}' returns isDuplicate: false</verify>
  <done>Duplicate detection endpoint enables pre-upload validation</done>
</task>

</tasks>

<verification>
1. Presigned URL endpoint validates file types
2. Multipart create returns uploadId and key
3. Sign-part returns properly formatted presigned URL
4. Complete endpoint returns location
5. Duplicate check returns isDuplicate boolean
</verification>

<success_criteria>
- All upload endpoints return Uppy-compatible response formats
- Invalid file types are rejected with 400
- Mock latencies simulate realistic network conditions
- Console logging aids debugging during development
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog-management/04-04-SUMMARY.md`
</output>
