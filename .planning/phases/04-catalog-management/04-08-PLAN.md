---
phase: 04-catalog-management
plan: 08
type: execute
wave: 4
depends_on: ["04-06"]
files_modified:
  - src/app/(platform)/assets/upload/page.tsx
  - src/app/(platform)/assets/upload/components/UploadForm.tsx
  - src/app/(platform)/assets/upload/components/SharedMetadataForm.tsx
  - src/app/(platform)/assets/upload/components/index.ts
autonomous: true

must_haves:
  truths:
    - "Upload page allows file selection via drag-drop or click"
    - "Shared metadata form captures contributor, genre, tags (applied to all files)"
    - "Asset titles derive from filenames (file-specific, not shared)"
    - "Files upload to mock S3 with progress tracking"
    - "Upload completion creates asset records"
  artifacts:
    - path: "src/app/(platform)/assets/upload/page.tsx"
      provides: "Asset upload page"
      exports: ["default"]
    - path: "src/app/(platform)/assets/upload/components/UploadForm.tsx"
      provides: "Complete upload form with dropzone and metadata"
      exports: ["UploadForm"]
    - path: "src/app/(platform)/assets/upload/components/SharedMetadataForm.tsx"
      provides: "Metadata input form"
      exports: ["SharedMetadataForm"]
  key_links:
    - from: "src/app/(platform)/assets/upload/page.tsx"
      to: "src/hooks/useUploader.tsx"
      via: "file upload management"
      pattern: "import.*useUploader"
---

<objective>
Build the asset upload page with multi-file support and shared metadata form.

Purpose: Contributors/staff can upload new assets with batch metadata assignment.
Output: Complete upload workflow from file selection to asset creation.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog-management/CONTEXT.md
@.planning/phases/04-catalog-management/04-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload page layout</name>
  <files>src/app/(platform)/assets/upload/page.tsx</files>
  <action>
Create the upload page:

```typescript
import { UploadForm } from './components'

export default function AssetUploadPage() {
  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-semibold text-gray-900">Upload Assets</h1>
        <p className="mt-1 text-sm text-gray-600">
          Upload new assets to the catalog. Select an asset type, add files, and fill in metadata.
        </p>
      </div>

      <UploadForm />
    </div>
  )
}
```

The page is a thin wrapper around UploadForm which handles all logic.

Add "Upload Assets" button to the assets list page header (or as a prominent action).
  </action>
  <verify>Page renders at /assets/upload</verify>
  <done>Upload page displays with form container</done>
</task>

<task type="auto">
  <name>Task 2: Create shared metadata form component</name>
  <files>src/app/(platform)/assets/upload/components/SharedMetadataForm.tsx</files>
  <action>
Create SharedMetadataForm for batch metadata.

NOTE: Per user decision, "shared metadata" refers to contributor, genre, and tags being
applied to ALL uploaded files. Title is intentionally NOT shared - each asset gets its
title derived from the source filename (file.name without extension). This is correct
behavior for batch uploads where files have meaningful names.

Props:
- assetType: AssetType (determines which fields to show)
- onChange: (metadata: SharedMetadata) => void
- disabled?: boolean

Fields per asset type (all are shared across files):

**All types:**
- Contributor (select/autocomplete - mock contributor list)
- Genre (select from predefined list)
- Tags (react-tag-autocomplete)

**Music only:**
- BPM (number input, can be auto-detected)
- Key (select: C, C#, D, D#, E, F, F#, G, G#, A, A#, B + Major/Minor)

**Video types (motion-graphics, stock-footage):**
- Resolution auto-detected, shown as read-only

SharedMetadata interface:
```typescript
interface SharedMetadata {
  contributorId: string
  contributorName: string
  genre: string
  tags: string[]
  bpm?: number
  key?: string
}
```

Genre options by type:
- Music: Rock, Pop, Electronic, Hip Hop, Cinematic, Classical, Jazz, Ambient, Folk, Country
- SFX: UI, Nature, Human, Transport, Industrial, Household, Animals, Weather
- Motion Graphics: Backgrounds, Transitions, Lower Thirds, Social Media, Logo Reveals
- Stock Footage: Nature, Urban, Business, Lifestyle, Technology, Travel
- LUTs: Cinematic, Vintage, B&W, Warm, Cool, HDR

Mock contributor list: Generate 20 contributor names for the select dropdown.

Use react-tag-autocomplete for tags with common tag suggestions.
  </action>
  <verify>Form renders all fields correctly based on asset type</verify>
  <done>Shared metadata form adapts fields to selected asset type</done>
</task>

<task type="auto">
  <name>Task 3: Create main upload form component</name>
  <files>src/app/(platform)/assets/upload/components/UploadForm.tsx, src/app/(platform)/assets/upload/components/index.ts</files>
  <action>
Create UploadForm that orchestrates the full upload workflow:

```typescript
'use client'

import { useState, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@music-vine/cadence'
import type { AssetType } from '@/types/asset'
import { useUploader } from '@/hooks/useUploader'
import { useDuplicateCheck } from '@/hooks/useDuplicateCheck'
import { validateFile } from '@/lib/upload'
import { FileDropzone, FileUploadList } from '@/components/upload'
import { SharedMetadataForm, type SharedMetadata } from './SharedMetadataForm'
import { toast } from 'sonner'

export function UploadForm() {
  const router = useRouter()
  const [assetType, setAssetType] = useState<AssetType>('music')
  const [metadata, setMetadata] = useState<SharedMetadata | null>(null)
  const [validationErrors, setValidationErrors] = useState<Map<string, string[]>>(new Map())

  const { checkDuplicate, checking: checkingDuplicates } = useDuplicateCheck()

  const uploader = useUploader({
    assetType,
    onFileComplete: (file) => {
      console.log('File complete:', file)
    },
    onAllComplete: async (files) => {
      // Create asset records for completed files
      if (!metadata) return

      try {
        for (const file of files) {
          await fetch('/api/assets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              type: assetType,
              // Use originalName (preserved from File object) for asset title, not name (which may be sanitized)
              title: file.originalName.replace(/\.[^/.]+$/, ''), // Remove extension from original filename
              fileKey: file.fileKey,
              ...metadata,
            }),
          })
        }
        toast.success(`${files.length} asset(s) uploaded successfully`)
        router.push('/assets')
      } catch (error) {
        toast.error('Failed to create asset records')
      }
    },
    onError: (file, error) => {
      toast.error(`Upload failed: ${file.name}`)
    },
  })

  const handleFilesSelected = useCallback(async (files: File[]) => {
    const newErrors = new Map<string, string[]>()

    for (const file of files) {
      // Validate file
      const validation = await validateFile(file, assetType)
      if (!validation.valid) {
        newErrors.set(file.name, validation.errors)
        continue
      }

      // Check for duplicates
      const duplicate = await checkDuplicate(file)
      if (duplicate.isDuplicate) {
        newErrors.set(file.name, [`Duplicate of existing asset: ${duplicate.existingAssetTitle}`])
        continue
      }

      // File is valid, add to uploader
      uploader.addFiles([file])

      // If music, update BPM from validation metadata
      if (assetType === 'music' && validation.metadata?.bpm) {
        setMetadata(prev => prev ? { ...prev, bpm: validation.metadata?.bpm } : null)
      }
    }

    setValidationErrors(newErrors)
  }, [assetType, checkDuplicate, uploader])

  const canStartUpload = uploader.files.length > 0 && metadata?.contributorId && !uploader.isUploading
  const hasValidationErrors = validationErrors.size > 0

  return (
    <div className="max-w-3xl space-y-8">
      {/* Step 1: Select asset type */}
      <section className="space-y-4">
        <h2 className="text-lg font-medium text-gray-900">1. Select Asset Type</h2>
        <div className="flex flex-wrap gap-2">
          {(['music', 'sfx', 'motion-graphics', 'lut', 'stock-footage'] as const).map((type) => (
            <button
              key={type}
              onClick={() => {
                setAssetType(type)
                uploader.clearFiles()
                setValidationErrors(new Map())
              }}
              disabled={uploader.isUploading}
              className={`
                px-4 py-2 rounded-lg border text-sm font-medium transition-colors
                ${assetType === type
                  ? 'border-platform-primary bg-platform-primary text-white'
                  : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
                }
                ${uploader.isUploading ? 'opacity-50 cursor-not-allowed' : ''}
              `}
            >
              {type === 'motion-graphics' ? 'Motion Graphics' :
               type === 'stock-footage' ? 'Stock Footage' :
               type === 'lut' ? 'LUTs' :
               type === 'sfx' ? 'SFX' :
               'Music'}
            </button>
          ))}
        </div>
      </section>

      {/* Step 2: Select files */}
      <section className="space-y-4">
        <h2 className="text-lg font-medium text-gray-900">2. Select Files</h2>
        <FileDropzone
          assetType={assetType}
          onFilesSelected={handleFilesSelected}
          disabled={uploader.isUploading}
        />

        {/* Validation errors */}
        {hasValidationErrors && (
          <div className="rounded-lg bg-red-50 border border-red-200 p-4 space-y-2">
            {Array.from(validationErrors.entries()).map(([filename, errors]) => (
              <div key={filename}>
                <p className="text-sm font-medium text-red-800">{filename}</p>
                <ul className="mt-1 text-sm text-red-600 list-disc list-inside">
                  {errors.map((error, i) => <li key={i}>{error}</li>)}
                </ul>
              </div>
            ))}
          </div>
        )}

        {/* File list */}
        <FileUploadList
          files={uploader.files}
          onRemove={uploader.removeFile}
          onRetry={uploader.retryFile}
        />
      </section>

      {/* Step 3: Metadata */}
      {uploader.files.length > 0 && (
        <section className="space-y-4">
          <h2 className="text-lg font-medium text-gray-900">3. Add Metadata</h2>
          <p className="text-sm text-gray-600">
            This metadata will be applied to all uploaded files.
          </p>
          <SharedMetadataForm
            assetType={assetType}
            onChange={setMetadata}
            disabled={uploader.isUploading}
          />
        </section>
      )}

      {/* Actions */}
      <div className="flex justify-end gap-4 pt-4 border-t">
        <Button
          variant="subtle"
          onClick={() => router.push('/assets')}
          disabled={uploader.isUploading}
        >
          Cancel
        </Button>
        <Button
          variant="bold"
          onClick={() => uploader.startUpload()}
          disabled={!canStartUpload}
        >
          {uploader.isUploading
            ? `Uploading... (${uploader.files.filter(f => f.status === 'complete').length}/${uploader.files.length})`
            : `Upload ${uploader.files.length} File${uploader.files.length === 1 ? '' : 's'}`}
        </Button>
      </div>
    </div>
  )
}
```

Create index.ts:
```typescript
export * from './UploadForm'
export * from './SharedMetadataForm'
```
  </action>
  <verify>Full upload flow works: select type, drop files, add metadata, upload</verify>
  <done>Upload form validates files, checks duplicates, uploads with progress, creates assets</done>
</task>

</tasks>

<verification>
1. Asset type selection changes allowed file types
2. Drag-drop adds files to list
3. Invalid files show validation errors
4. Duplicate files show warning with existing asset title
5. Metadata form shows correct fields for asset type
6. Upload button disabled until files and metadata present
7. Progress updates during upload
8. Success redirects to asset list
</verification>

<success_criteria>
- Multi-file upload with shared metadata (contributor, genre, tags applied to all)
- Asset titles derive from filenames (intentionally not shared)
- Per-file validation with clear error messages
- Duplicate detection prevents re-uploading same files
- BPM auto-detection for music (optional fill)
- Upload creates asset records on completion
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog-management/04-08-SUMMARY.md`
</output>
