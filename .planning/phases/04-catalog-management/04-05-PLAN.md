---
phase: 04-catalog-management
plan: 05
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/lib/upload/file-hash.ts
  - src/lib/upload/media-metadata.ts
  - src/lib/upload/bpm-detector.ts
  - src/lib/upload/file-validation.ts
  - src/lib/upload/index.ts
autonomous: true

must_haves:
  truths:
    - "Files can be hashed client-side using Web Crypto API"
    - "Audio/video duration extracted via HTML5 media elements"
    - "BPM detection works for music files"
    - "File validation checks type, size, and extracts metadata"
  artifacts:
    - path: "src/lib/upload/file-hash.ts"
      provides: "SHA-256 file hashing"
      exports: ["hashFile"]
    - path: "src/lib/upload/media-metadata.ts"
      provides: "Duration and resolution extraction"
      exports: ["extractMediaMetadata"]
    - path: "src/lib/upload/bpm-detector.ts"
      provides: "Audio BPM detection"
      exports: ["detectBPM"]
    - path: "src/lib/upload/file-validation.ts"
      provides: "Complete file validation with metadata"
      exports: ["validateFile", "ValidationResult"]
  key_links:
    - from: "src/lib/upload/file-validation.ts"
      to: "src/lib/upload/media-metadata.ts"
      via: "imports extractMediaMetadata"
      pattern: "import.*extractMediaMetadata"
---

<objective>
Create client-side file processing utilities for hashing, metadata extraction, and validation.

Purpose: Enable pre-upload validation and metadata prefilling without server round-trips.
Output: Utility functions for file hashing, media metadata extraction, BPM detection, and comprehensive validation.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog-management/CONTEXT.md
@.planning/phases/04-catalog-management/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file hashing and metadata extraction utilities</name>
  <files>src/lib/upload/file-hash.ts, src/lib/upload/media-metadata.ts</files>
  <action>
Create src/lib/upload/file-hash.ts per RESEARCH pattern:
```typescript
/**
 * Hash file contents using SHA-256 via Web Crypto API.
 * Returns hex string of hash.
 * Note: For large files (>1GB), consider showing progress indicator.
 */
export async function hashFile(file: File): Promise<string> {
  const buffer = await file.arrayBuffer()
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
}
```

Create src/lib/upload/media-metadata.ts per RESEARCH pattern:
```typescript
export interface MediaMetadata {
  duration: number // seconds
  width?: number   // video only
  height?: number  // video only
}

/**
 * Extract media metadata using HTML5 media elements.
 * Works for audio (mp3, wav, flac) and video (mp4, mov) files.
 */
export function extractMediaMetadata(file: File): Promise<MediaMetadata> {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file)
    const isVideo = file.type.startsWith('video/')
    const element = isVideo
      ? document.createElement('video')
      : document.createElement('audio')

    element.preload = 'metadata'

    element.onloadedmetadata = () => {
      const metadata: MediaMetadata = {
        duration: element.duration,
      }

      if (isVideo && element instanceof HTMLVideoElement) {
        metadata.width = element.videoWidth
        metadata.height = element.videoHeight
      }

      URL.revokeObjectURL(url)
      resolve(metadata)
    }

    element.onerror = () => {
      URL.revokeObjectURL(url)
      reject(new Error(`Failed to load metadata for ${file.name}`))
    }

    element.src = url
  })
}

/**
 * Format resolution string from width/height.
 */
export function formatResolution(width: number, height: number): string {
  return `${width}x${height}`
}
```

Both functions work client-side only (browser APIs).
  </action>
  <verify>Functions compile and can be imported in a test file</verify>
  <done>File hashing and media metadata extraction ready for pre-upload validation</done>
</task>

<task type="auto">
  <name>Task 2: Create BPM detection wrapper</name>
  <files>src/lib/upload/bpm-detector.ts</files>
  <action>
Create BPM detection wrapper per RESEARCH pattern:
```typescript
import { guess } from 'web-audio-beat-detector'

/**
 * Detect BPM of audio file using Web Audio API.
 * Returns rounded BPM value.
 *
 * Important: Always closes AudioContext after use to avoid memory leaks
 * and "too many AudioContexts" errors.
 *
 * Note: BPM detection can fail for some audio types (speech, ambient).
 * Caller should handle errors gracefully (BPM is optional for music).
 */
export async function detectBPM(file: File): Promise<number> {
  const arrayBuffer = await file.arrayBuffer()
  const audioContext = new AudioContext()

  try {
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
    const { bpm } = await guess(audioBuffer)
    return Math.round(bpm)
  } finally {
    await audioContext.close()
  }
}

/**
 * Safe BPM detection that returns null instead of throwing.
 * Use this when BPM is optional (prefilling form field).
 */
export async function detectBPMSafe(file: File): Promise<number | null> {
  try {
    return await detectBPM(file)
  } catch (error) {
    console.warn('BPM detection failed:', error)
    return null
  }
}
```

The `finally` block ensures AudioContext is always closed per RESEARCH pitfall #3.
  </action>
  <verify>Function compiles and exports correctly</verify>
  <done>BPM detection wrapper handles AudioContext lifecycle correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive file validation</name>
  <files>src/lib/upload/file-validation.ts, src/lib/upload/index.ts</files>
  <action>
Create src/lib/upload/file-validation.ts per RESEARCH pattern:
```typescript
import type { AssetType } from '@/types/asset'
import { extractMediaMetadata, formatResolution } from './media-metadata'
import { detectBPMSafe } from './bpm-detector'

export interface ValidationResult {
  valid: boolean
  errors: string[]
  metadata?: {
    duration?: number
    resolution?: string
    bpm?: number
  }
}

const allowedTypes: Record<AssetType, string[]> = {
  music: ['.mp3', '.wav', '.flac', '.aiff'],
  sfx: ['.mp3', '.wav'],
  'motion-graphics': ['.mp4', '.mov'],
  lut: ['.cube', '.3dl'],
  'stock-footage': ['.mp4', '.mov'],
}

const maxFileSize = 5 * 1024 * 1024 * 1024 // 5GB per CONTEXT

/**
 * Validate file for upload, checking type, size, and extracting metadata.
 */
export async function validateFile(file: File, assetType: AssetType): Promise<ValidationResult> {
  const errors: string[] = []
  const metadata: ValidationResult['metadata'] = {}

  // Check file extension
  const extension = '.' + file.name.split('.').pop()?.toLowerCase()
  if (!allowedTypes[assetType]?.includes(extension)) {
    errors.push(`Invalid file type for ${assetType}. Allowed: ${allowedTypes[assetType].join(', ')}`)
  }

  // Check file size
  if (file.size > maxFileSize) {
    errors.push(`File too large. Maximum size: 5GB`)
  }

  // Extract metadata if file type is valid
  if (errors.length === 0) {
    try {
      if (assetType === 'music' || assetType === 'sfx') {
        const mediaData = await extractMediaMetadata(file)
        metadata.duration = mediaData.duration

        // BPM detection for music only (optional, don't fail on error)
        if (assetType === 'music') {
          metadata.bpm = await detectBPMSafe(file) ?? undefined
        }
      } else if (['motion-graphics', 'stock-footage'].includes(assetType)) {
        const mediaData = await extractMediaMetadata(file)
        metadata.duration = mediaData.duration
        if (mediaData.width && mediaData.height) {
          metadata.resolution = formatResolution(mediaData.width, mediaData.height)
        }
      }
      // LUTs don't need metadata extraction
    } catch (e) {
      errors.push(`Failed to read file metadata: ${(e as Error).message}`)
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    metadata: errors.length === 0 ? metadata : undefined,
  }
}

/**
 * Get allowed file types for an asset type.
 */
export function getAllowedTypes(assetType: AssetType): string[] {
  return allowedTypes[assetType] || []
}

/**
 * Format file size for display.
 */
export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`
}
```

Create src/lib/upload/index.ts to re-export all:
```typescript
export * from './file-hash'
export * from './media-metadata'
export * from './bpm-detector'
export * from './file-validation'
```
  </action>
  <verify>All exports compile and can be imported from '@/lib/upload'</verify>
  <done>File validation centralizes all pre-upload checks with metadata extraction</done>
</task>

</tasks>

<verification>
1. hashFile returns 64-character hex string
2. extractMediaMetadata returns duration for audio files
3. extractMediaMetadata returns duration, width, height for video files
4. detectBPMSafe returns number or null without throwing
5. validateFile returns valid:true with metadata for valid files
6. validateFile returns valid:false with errors for invalid files
</verification>

<success_criteria>
- All utilities work in browser environment (not Node.js APIs)
- AudioContext properly closed after BPM detection
- Validation errors are user-friendly messages
- Metadata extraction handles both audio and video
- Re-exports work from '@/lib/upload'
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog-management/04-05-SUMMARY.md`
</output>
