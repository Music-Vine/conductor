---
phase: 04-catalog-management
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/assets/route.ts
  - src/app/api/assets/[id]/route.ts
  - src/app/api/assets/[id]/workflow/route.ts
  - src/app/api/assets/[id]/approve/route.ts
  - src/app/api/assets/[id]/reject/route.ts
  - src/app/api/assets/[id]/unpublish/route.ts
  - src/lib/api/assets.ts
  - src/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Mock API returns paginated asset lists with filtering"
    - "Asset detail endpoint returns full asset with workflow history"
    - "Workflow action endpoints update asset state correctly"
    - "Unpublish endpoint supports asset takedowns (CATA-09)"
  artifacts:
    - path: "src/app/api/assets/route.ts"
      provides: "Asset list and create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/assets/[id]/route.ts"
      provides: "Asset detail and update endpoints"
      exports: ["GET", "PATCH"]
    - path: "src/app/api/assets/[id]/approve/route.ts"
      provides: "Workflow approval endpoint"
      exports: ["POST"]
    - path: "src/app/api/assets/[id]/reject/route.ts"
      provides: "Workflow rejection endpoint"
      exports: ["POST"]
    - path: "src/app/api/assets/[id]/unpublish/route.ts"
      provides: "Asset unpublish endpoint for takedowns"
      exports: ["POST"]
    - path: "src/lib/api/assets.ts"
      provides: "Client-side API functions"
      exports: ["getAssets", "getAsset", "approveAsset", "rejectAsset", "unpublishAsset"]
  key_links:
    - from: "src/app/api/assets/route.ts"
      to: "src/types/asset.ts"
      via: "imports Asset types"
      pattern: "import.*from.*types/asset"
---

<objective>
Create mock API routes for asset CRUD and workflow actions.

Purpose: Enable frontend development with realistic mock data before backend integration.
Output: Complete mock API for assets with filtering, pagination, and workflow state transitions.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog-management/CONTEXT.md
@.planning/phases/04-catalog-management/04-01-SUMMARY.md

# Existing API patterns to follow
@src/app/api/users/route.ts
@src/app/api/users/[id]/route.ts
@src/lib/api/users.ts
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create asset list and create endpoints</name>
  <files>src/app/api/assets/route.ts</files>
  <action>
Create GET and POST handlers following the user API pattern.

GET /api/assets:
- Query params: type, status, platform, genre, query (search), page, limit
- Generate mock assets using ID-based seeding (same pattern as users)
- Return paginated response: { data: AssetListItem[], pagination: { page, pageSize, totalPages, totalItems } }
- Filter by type (music, sfx, etc.), status (workflow state), platform, genre
- Search by title (case-insensitive contains)
- Default limit: 50, max: 100
- Add 100-200ms artificial latency

POST /api/assets:
- Accept: { type, title, description?, contributorId, fileKey, genre, tags?, ...type-specific fields }
- Create mock asset with 'draft' status
- Return created asset with generated ID
- Platform defaults: 'both' for music, 'uppbeat' for others

Mock data generation:
- Generate 500 assets total across all types
- Distribution: 300 music, 80 sfx, 50 motion-graphics, 30 luts, 40 stock-footage
- Random statuses weighted toward published (40%), submitted (20%), in-review (20%), draft (10%), rejected (10%)
- Generate realistic titles: "Summer Vibes", "Corporate Motivation", "Epic Cinematic"
- Generate contributor names from a pool of 50 mock contributors
- Random genres from predefined lists per asset type
- Random durations, BPMs, resolutions appropriate to type
  </action>
  <verify>curl localhost:3000/api/assets?type=music&status=published returns filtered list</verify>
  <done>Asset list endpoint returns paginated, filterable mock data</done>
</task>

<task type="auto">
  <name>Task 2: Create asset detail and workflow endpoints</name>
  <files>src/app/api/assets/[id]/route.ts, src/app/api/assets/[id]/workflow/route.ts, src/app/api/assets/[id]/approve/route.ts, src/app/api/assets/[id]/reject/route.ts, src/app/api/assets/[id]/unpublish/route.ts</files>
  <action>
Create asset detail and workflow action endpoints:

GET /api/assets/[id]:
- Return full Asset object (not AssetListItem)
- Include mock fileUrl (placeholder S3 presigned URL)
- Include mock workflow history (2-5 history items based on current status)
- 100-200ms latency

PATCH /api/assets/[id]:
- Update metadata fields (title, description, tags, genre, platform for music)
- Return updated asset
- Log mock audit entry

GET /api/assets/[id]/workflow:
- Return workflow history array: WorkflowHistoryItem[]
- Generate realistic history based on current status
- If published: include all approval stages
- If in-review: include stages up to current point

POST /api/assets/[id]/approve:
- Accept: { checklist?: ChecklistItem[], comments?: string, platform?: 'music-vine' | 'uppbeat' | 'both' }
- Hybrid feedback: checklist tracks what was reviewed, comments for additional notes
- Both checklist and comments are optional (Quick Approve may auto-populate checklist)
- Use workflow/transitions to get next state
- If music in platform_assignment state, require platform field
- Return updated asset with new state
- Fail with 400 if action not available in current state

POST /api/assets/[id]/reject:
- Accept: { checklist?: ChecklistItem[], comments: string } (comments required for rejection)
- Use workflow/transitions to get rejected state
- Return updated asset with rejected state

POST /api/assets/[id]/unpublish:
- Move published asset back to draft
- Return updated asset
- Fail with 400 if asset not published
  </action>
  <verify>curl localhost:3000/api/assets/mock-id-1 returns asset detail with workflow history</verify>
  <done>Workflow endpoints correctly transition states using workflow/transitions logic</done>
</task>

<task type="auto">
  <name>Task 3: Create client-side API functions and update middleware</name>
  <files>src/lib/api/assets.ts, src/middleware.ts</files>
  <action>
Create src/lib/api/assets.ts:
- Export `getAssets(params: AssetSearchParams)` - fetches asset list with filters
- Export `getAsset(id: string)` - fetches asset detail
- Export `createAsset(data)` - creates new asset
- Export `updateAsset(id, data)` - updates asset metadata
- Export `getWorkflowHistory(id)` - fetches workflow history
- Export `approveAsset(id, data)` - approves at current stage
- Export `rejectAsset(id, data)` - rejects with feedback
- Export `unpublishAsset(id)` - unpublishes asset

All functions use the apiClient from src/lib/api/client.ts, following the users.ts pattern.

Update src/middleware.ts:
- Add /api/assets to public paths (for mock development, same as users)
- Ensure /api/assets/* routes are accessible
  </action>
  <verify>Import works: `import { getAssets } from '@/lib/api/assets'`</verify>
  <done>Client API functions ready for use in React components</done>
</task>

</tasks>

<verification>
1. GET /api/assets returns paginated list
2. GET /api/assets?type=music filters correctly
3. GET /api/assets/[id] returns full asset detail
4. POST /api/assets/[id]/approve transitions state correctly
5. Client functions can be imported without errors
</verification>

<success_criteria>
- Mock API generates realistic asset data
- Filtering works for type, status, platform, genre, query
- Workflow transitions enforce state machine rules
- 400 error returned for invalid workflow actions
- Client API functions match the users.ts pattern
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog-management/04-03-SUMMARY.md`
</output>
