---
phase: 02-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/user.ts
  - src/lib/api/users.ts
  - src/app/api/users/route.ts
  - src/app/api/users/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "User type definitions exist with all required fields"
    - "Mock API returns paginated user list"
    - "Mock API returns individual user details"
  artifacts:
    - path: "src/types/user.ts"
      provides: "User, UserStatus, SubscriptionTier types"
      exports: ["User", "UserStatus", "SubscriptionTier", "UserListItem", "UserDetail"]
    - path: "src/lib/api/users.ts"
      provides: "User API client functions"
      exports: ["fetchUsers", "fetchUser"]
    - path: "src/app/api/users/route.ts"
      provides: "GET /api/users endpoint"
      exports: ["GET"]
    - path: "src/app/api/users/[id]/route.ts"
      provides: "GET /api/users/[id] endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/lib/api/users.ts"
      to: "/api/users"
      via: "apiClient.get"
      pattern: "apiClient\\.get.*users"
---

<objective>
Create User types and mock API routes for user management.

Purpose: Establish the data contract and mock endpoints that all user management UI will consume. Mock data enables frontend-first development while generating API requirements for backend team.

Output: User type definitions, API client functions, and mock GET endpoints for user list and detail.
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management/02-CONTEXT.md
@.planning/phases/02-user-management/02-RESEARCH.md

@src/types/api.ts
@src/types/platform.ts
@src/lib/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User type definitions</name>
  <files>src/types/user.ts, src/types/index.ts</files>
  <action>
Create comprehensive User types in src/types/user.ts:

1. UserStatus enum: 'active' | 'suspended'
2. SubscriptionTier enum: 'free' | 'creator' | 'pro' | 'enterprise'
3. OAuthConnection type: { provider: 'google' | 'facebook', connectedAt: string, email: string }
4. UserListItem type (for table rows):
   - id: string
   - email: string
   - name: string | null
   - username: string | null
   - status: UserStatus
   - subscriptionTier: SubscriptionTier
   - platform: Platform (from existing types)
   - lastLoginAt: string | null
   - createdAt: string

5. UserDetail type (extends UserListItem, for detail view):
   - All UserListItem fields
   - suspendedAt: string | null
   - suspendedReason: string | null
   - oauthConnections: OAuthConnection[]
   - subscription: { tier, startedAt, expiresAt, billingEmail }
   - downloadCount: number
   - licenseCount: number

6. UserSearchParams type:
   - query?: string
   - status?: UserStatus
   - tier?: SubscriptionTier
   - platform?: Platform
   - page?: number
   - limit?: number

Export all types and add to src/types/index.ts barrel export.

Use string literal unions (not enums) to match existing Platform type pattern.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>User types exported and usable throughout codebase</done>
</task>

<task type="auto">
  <name>Task 2: Create User API client functions</name>
  <files>src/lib/api/users.ts, src/lib/api/index.ts</files>
  <action>
Create API client functions in src/lib/api/users.ts:

1. fetchUsers(params: UserSearchParams): Promise<PaginatedResponse<UserListItem>>
   - Build query string from params
   - Call apiClient.get('/users', { params })
   - Return typed PaginatedResponse

2. fetchUser(id: string): Promise<UserDetail>
   - Call apiClient.get(`/users/${id}`)
   - Return typed UserDetail

Import apiClient from './client' and types from '@/types'.
Use existing PaginatedResponse type from api.ts.
Add barrel export in src/lib/api/index.ts.
  </action>
  <verify>`npm run build` passes with no type errors</verify>
  <done>fetchUsers and fetchUser functions available for use</done>
</task>

<task type="auto">
  <name>Task 3: Create mock GET /api/users endpoint</name>
  <files>src/app/api/users/route.ts</files>
  <action>
Create mock users list endpoint:

1. Parse searchParams: query, status, tier, platform, page (default 1), limit (default 50, max 100)
2. Generate 100 mock users with realistic data:
   - Use faker-like patterns (email patterns, names)
   - Mix of statuses (90% active, 10% suspended)
   - Mix of tiers (40% free, 30% creator, 20% pro, 10% enterprise)
   - Random lastLoginAt within last 30 days
3. Filter mock data based on params:
   - query: filter by email/name/username/id (case-insensitive contains)
   - status: exact match
   - tier: exact match
   - platform: exact match
4. Paginate filtered results
5. Return PaginatedResponse format matching api.ts types

Use NextRequest/NextResponse from 'next/server'.
Add artificial 200ms delay to simulate network latency.
  </action>
  <verify>`curl 'http://localhost:3000/api/users?page=1&limit=10'` returns JSON with results array and pagination object</verify>
  <done>GET /api/users returns mock paginated user data</done>
</task>

<task type="auto">
  <name>Task 4: Create mock GET /api/users/[id] endpoint</name>
  <files>src/app/api/users/[id]/route.ts</files>
  <action>
Create mock user detail endpoint:

1. Extract id from params (await params in Next.js 15 style)
2. Generate detailed mock user matching the id:
   - All UserListItem fields
   - suspendedAt/suspendedReason if status is suspended
   - 0-3 OAuth connections (mix of google/facebook)
   - Subscription details (tier, dates, billing email)
   - Random downloadCount (0-500)
   - Random licenseCount (0-50)
3. Return 404 if id doesn't match expected pattern
4. Return UserDetail response

Add artificial 100ms delay.
  </action>
  <verify>`curl 'http://localhost:3000/api/users/user-123'` returns JSON with full user detail</verify>
  <done>GET /api/users/[id] returns mock user detail</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Start dev server: `npm run dev`
3. Test list endpoint: `curl 'http://localhost:3000/api/users?page=1&limit=5'`
4. Test search: `curl 'http://localhost:3000/api/users?query=test'`
5. Test detail endpoint: `curl 'http://localhost:3000/api/users/user-1'`
</verification>

<success_criteria>
- User types defined and exported
- API client functions typed and working
- GET /api/users returns paginated mock data with filtering
- GET /api/users/[id] returns detailed mock user
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management/02-01-SUMMARY.md`
</output>
