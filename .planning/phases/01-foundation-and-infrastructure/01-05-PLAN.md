---
phase: 01-foundation-and-infrastructure
plan: 05
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/providers/QueryProvider.tsx
  - src/providers/index.ts
  - src/lib/api/client.ts
  - src/lib/api/index.ts
autonomous: true

must_haves:
  truths:
    - "React Query provider is available for wrapping application"
    - "API client can make authenticated requests with proper headers"
    - "API responses are typed with proper error handling"
  artifacts:
    - path: "src/providers/QueryProvider.tsx"
      provides: "React Query provider setup"
      exports: ["QueryProvider"]
    - path: "src/lib/api/client.ts"
      provides: "Base API client"
      exports: ["apiClient", "createApiClient"]
  key_links:
    - from: "src/lib/api/client.ts"
      to: "API endpoints"
      via: "fetch wrapper"
      pattern: "fetch\\("
---

<objective>
Set up React Query provider for server state management and create a typed API client for making authenticated requests to the backend.

Purpose: This establishes the data fetching infrastructure that all API calls will use. React Query provides caching, refetching, and optimistic updates. The API client ensures consistent error handling and authentication headers.

Output: QueryProvider in providers/, API client in lib/api/
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create React Query provider</name>
  <files>
src/providers/QueryProvider.tsx
src/providers/index.ts
  </files>
  <action>
Create React Query provider with proper configuration for Next.js App Router.

**src/providers/QueryProvider.tsx:**
```typescript
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState, type ReactNode } from 'react'

interface QueryProviderProps {
  children: ReactNode
}

/**
 * React Query Provider for Next.js App Router.
 *
 * Uses useState to create a singleton QueryClient that persists
 * across re-renders but is unique per request in SSR.
 *
 * Configuration:
 * - staleTime: 60s (data considered fresh for 1 minute)
 * - refetchOnWindowFocus: false (don't refetch when tab gains focus)
 * - retry: 1 (retry failed requests once)
 */
export function QueryProvider({ children }: QueryProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Data is fresh for 60 seconds
            staleTime: 60 * 1000,
            // Don't refetch on window focus (admin app, explicit refreshes)
            refetchOnWindowFocus: false,
            // Retry failed requests once
            retry: 1,
            // Retry delay with exponential backoff
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
          mutations: {
            // Don't retry mutations by default
            retry: false,
          },
        },
      })
  )

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

**Update src/providers/index.ts** to add the export:
```typescript
export { JotaiProvider } from './JotaiProvider'
export { ThemeProvider } from './ThemeProvider'
export { QueryProvider } from './QueryProvider'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. QueryProvider is exported from src/providers/index.ts
3. QueryProvider uses 'use client' directive
  </verify>
  <done>
QueryProvider exists with proper singleton pattern for QueryClient. Default options configured for admin app use case (60s stale time, no refetch on focus).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create typed API client</name>
  <files>
src/lib/api/client.ts
src/lib/api/index.ts
  </files>
  <action>
Create a typed fetch wrapper that handles authentication, platform context, and error responses.

**src/lib/api/client.ts:**
```typescript
import type { ApiResponse, ApiError, ApiClientConfig } from '@/types'

/**
 * Custom API Error class with structured error data.
 */
export class ApiClientError extends Error {
  public code: string
  public status: number
  public details?: Record<string, unknown>

  constructor(message: string, code: string, status: number, details?: Record<string, unknown>) {
    super(message)
    this.name = 'ApiClientError'
    this.code = code
    this.status = status
    this.details = details
  }
}

/**
 * Default API client configuration.
 */
const defaultConfig: ApiClientConfig = {
  baseUrl: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
}

/**
 * Creates an API client with the given configuration.
 */
export function createApiClient(config: Partial<ApiClientConfig> = {}) {
  const finalConfig = { ...defaultConfig, ...config }

  async function request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${finalConfig.baseUrl}${endpoint}`

    const headers = new Headers({
      ...finalConfig.headers,
      ...options.headers,
    })

    const response = await fetch(url, {
      ...options,
      headers,
      credentials: 'include', // Include cookies for session auth
    })

    // Handle non-JSON responses (like 204 No Content)
    if (response.status === 204) {
      return {} as T
    }

    // Try to parse JSON response
    let data: ApiResponse<T> | ApiError

    try {
      data = await response.json()
    } catch {
      // Non-JSON response
      if (!response.ok) {
        throw new ApiClientError(
          `Request failed: ${response.statusText}`,
          'UNKNOWN_ERROR',
          response.status
        )
      }
      return {} as T
    }

    // Check for API error response
    if (!response.ok) {
      const error = data as ApiError
      throw new ApiClientError(
        error.message || `Request failed with status ${response.status}`,
        error.code || 'API_ERROR',
        response.status,
        error.details
      )
    }

    // Return data from successful response
    const successResponse = data as ApiResponse<T>
    return successResponse.data ?? (data as T)
  }

  return {
    /**
     * GET request
     */
    get<T>(endpoint: string, options?: RequestInit): Promise<T> {
      return request<T>(endpoint, { ...options, method: 'GET' })
    },

    /**
     * POST request
     */
    post<T>(endpoint: string, body?: unknown, options?: RequestInit): Promise<T> {
      return request<T>(endpoint, {
        ...options,
        method: 'POST',
        body: body ? JSON.stringify(body) : undefined,
      })
    },

    /**
     * PUT request
     */
    put<T>(endpoint: string, body?: unknown, options?: RequestInit): Promise<T> {
      return request<T>(endpoint, {
        ...options,
        method: 'PUT',
        body: body ? JSON.stringify(body) : undefined,
      })
    },

    /**
     * PATCH request
     */
    patch<T>(endpoint: string, body?: unknown, options?: RequestInit): Promise<T> {
      return request<T>(endpoint, {
        ...options,
        method: 'PATCH',
        body: body ? JSON.stringify(body) : undefined,
      })
    },

    /**
     * DELETE request
     */
    delete<T>(endpoint: string, options?: RequestInit): Promise<T> {
      return request<T>(endpoint, { ...options, method: 'DELETE' })
    },

    /**
     * Raw request for custom methods or configurations
     */
    request,
  }
}

/**
 * Default API client instance.
 * Use this for most API calls.
 */
export const apiClient = createApiClient()

/**
 * Create a platform-specific API client.
 * The baseUrl is determined by the platform atom, but since atoms are
 * client-side only, this should be called from components with the
 * platform-specific base URL.
 */
export function createPlatformApiClient(baseUrl: string) {
  return createApiClient({ baseUrl })
}
```

**src/lib/api/index.ts:**
```typescript
export {
  apiClient,
  createApiClient,
  createPlatformApiClient,
  ApiClientError,
} from './client'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. API client exports are available from src/lib/api/index.ts
3. ApiClientError class is properly typed
  </verify>
  <done>
API client exists with typed get/post/put/patch/delete methods. Custom ApiClientError provides structured error handling. Platform-specific client factory available.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. QueryProvider can be imported: `import { QueryProvider } from '@/providers'`
3. API client can be imported: `import { apiClient, ApiClientError } from '@/lib/api'`
4. API client methods are properly typed with generics
</verification>

<success_criteria>
- QueryProvider uses singleton QueryClient pattern for Next.js
- QueryClient has sensible defaults (60s stale time, no window focus refetch)
- API client handles authentication via cookies (credentials: 'include')
- API client provides typed methods (get, post, put, patch, delete)
- ApiClientError provides structured error information (code, status, details)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-infrastructure/01-05-SUMMARY.md`
</output>
