---
phase: 01-foundation-and-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/login/actions.ts
  - src/app/(auth)/magic-link/page.tsx
  - src/app/(auth)/magic-link/actions.ts
  - src/app/(auth)/layout.tsx
  - src/app/api/auth/logout/route.ts
  - src/lib/auth/magic-link.ts
autonomous: true

must_haves:
  truths:
    - "Staff can enter email on login page to request magic link"
    - "Staff can check Remember Me to extend session to 30 days"
    - "Magic link callback page validates token and creates session"
    - "Staff can log out from any authenticated page"
    - "Login page shows clear feedback after magic link is sent"
  artifacts:
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page UI"
      exports: ["default"]
    - path: "src/app/(auth)/magic-link/page.tsx"
      provides: "Magic link callback handler"
      exports: ["default"]
    - path: "src/app/api/auth/logout/route.ts"
      provides: "Logout API endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/(auth)/login/actions.ts"
      to: "src/lib/auth/magic-link.ts"
      via: "requestMagicLink import"
      pattern: "import.*requestMagicLink"
    - from: "src/app/(auth)/magic-link/actions.ts"
      to: "src/lib/auth/session.ts"
      via: "createSession import"
      pattern: "import.*createSession"
---

<objective>
Implement the authentication flow with magic link login, callback handling, and logout functionality.

Purpose: This enables AUTH-01 (individual credentials via magic link), AUTH-02 (session creation), and AUTH-03 (logout from any page). The UI follows CONTEXT.md decisions: minimal, fast, just email field.

Output: Login page, magic link callback page, logout API route, auth utilities
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-and-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth route group layout and magic link utilities</name>
  <files>
src/app/(auth)/layout.tsx
src/lib/auth/magic-link.ts
src/lib/auth/index.ts
  </files>
  <action>
Create the auth route group layout and magic link utilities.

**src/app/(auth)/layout.tsx:**
```typescript
import type { ReactNode } from 'react'

interface AuthLayoutProps {
  children: ReactNode
}

/**
 * Layout for authentication pages (login, magic-link callback).
 * Minimal design per CONTEXT.md: focus on speed, no distractions.
 */
export default function AuthLayout({ children }: AuthLayoutProps) {
  return (
    <div className="flex min-h-screen items-center justify-center bg-zinc-50 dark:bg-zinc-950">
      <div className="w-full max-w-md px-4">
        {children}
      </div>
    </div>
  )
}
```

**src/lib/auth/magic-link.ts:**
```typescript
import { SignJWT, jwtVerify } from 'jose'

const MAGIC_LINK_EXPIRY_MS = 15 * 60 * 1000 // 15 minutes

function getMagicLinkSecret(): Uint8Array {
  const secret = process.env.MAGIC_LINK_SECRET || process.env.SESSION_SECRET
  if (!secret) {
    throw new Error('MAGIC_LINK_SECRET or SESSION_SECRET must be set')
  }
  return new TextEncoder().encode(secret)
}

interface MagicLinkPayload {
  email: string
  expiresAt: number
  nonce: string
  rememberMe: boolean
}

/**
 * Generates a magic link token for the given email.
 *
 * In production, this would:
 * 1. Store the nonce in database (one-time use)
 * 2. Send email via SES
 * 3. Return success
 *
 * For frontend-first development, we generate the token and log it.
 *
 * @param email - User's email address
 * @param rememberMe - Whether to extend session to 30 days
 */
export async function generateMagicLinkToken(
  email: string,
  rememberMe: boolean = false
): Promise<string> {
  const nonce = crypto.randomUUID()
  const expiresAt = Date.now() + MAGIC_LINK_EXPIRY_MS

  const payload: MagicLinkPayload = {
    email,
    expiresAt,
    nonce,
    rememberMe,
  }

  const token = await new SignJWT(payload as unknown as Record<string, unknown>)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime(new Date(expiresAt))
    .sign(getMagicLinkSecret())

  return token
}

/**
 * Validates a magic link token and returns the email and rememberMe preference if valid.
 *
 * In production, this would also:
 * 1. Check nonce hasn't been used (database lookup)
 * 2. Mark nonce as used
 */
export async function validateMagicLinkToken(
  token: string
): Promise<{ email: string; rememberMe: boolean } | null> {
  try {
    const { payload } = await jwtVerify(token, getMagicLinkSecret())
    const magicPayload = payload as unknown as MagicLinkPayload

    // Check expiry
    if (magicPayload.expiresAt <= Date.now()) {
      return null
    }

    // In production: check nonce hasn't been used

    return {
      email: magicPayload.email,
      rememberMe: magicPayload.rememberMe ?? false,
    }
  } catch {
    return null
  }
}

/**
 * Requests a magic link for the given email.
 *
 * This is a mock implementation for frontend development.
 * Returns the magic link URL for testing (in production, this would be sent via email).
 *
 * @param email - User's email address
 * @param rememberMe - If true, session will be extended to 30 days per CONTEXT.md
 */
export async function requestMagicLink(
  email: string,
  rememberMe: boolean = false
): Promise<{ success: boolean; debugUrl?: string }> {
  // Basic email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    return { success: false }
  }

  // In production: Check if email belongs to a staff member
  // For now, accept any valid email format

  // Include rememberMe in token so callback can use it
  const token = await generateMagicLinkToken(email, rememberMe)

  // Build magic link URL
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
  const magicLinkUrl = `${baseUrl}/magic-link?token=${token}`

  // In production: Send email via SES/SendGrid
  // For development: Log the URL and return it
  if (process.env.NODE_ENV === 'development') {
    console.log('\n=== MAGIC LINK (Development Only) ===')
    console.log(`Email: ${email}`)
    console.log(`Remember Me: ${rememberMe}`)
    console.log(`Link: ${magicLinkUrl}`)
    console.log('=====================================\n')
    return { success: true, debugUrl: magicLinkUrl }
  }

  return { success: true }
}
```

**Update src/lib/auth/index.ts** to add exports:
```typescript
export {
  createSession,
  getSession,
  updateSession,
  destroySession,
  getSessionPayload,
} from './session'

export {
  requestMagicLink,
  generateMagicLinkToken,
  validateMagicLinkToken,
} from './magic-link'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Auth layout exists at src/app/(auth)/layout.tsx
3. Magic link functions exported from src/lib/auth/index.ts
  </verify>
  <done>
Auth route group layout provides minimal centered container. Magic link utilities handle token generation and validation with development logging for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create login page with server actions</name>
  <files>
src/app/(auth)/login/page.tsx
src/app/(auth)/login/actions.ts
  </files>
  <action>
Create the login page with email input and server actions for magic link request.

**src/app/(auth)/login/actions.ts:**
```typescript
'use server'

import { requestMagicLink } from '@/lib/auth'

export interface LoginState {
  success: boolean
  message?: string
  debugUrl?: string // Only in development
}

export async function loginAction(
  prevState: LoginState | null,
  formData: FormData
): Promise<LoginState> {
  const email = formData.get('email')
  const rememberMe = formData.get('rememberMe') === 'on'

  if (typeof email !== 'string' || !email) {
    return {
      success: false,
      message: 'Please enter your email address',
    }
  }

  // Pass rememberMe preference to magic link generation
  // The token will include this preference for the callback to use
  const result = await requestMagicLink(email, rememberMe)

  if (!result.success) {
    return {
      success: false,
      message: 'Please enter a valid email address',
    }
  }

  return {
    success: true,
    message: 'Check your email for a magic link to sign in',
    debugUrl: result.debugUrl, // Only present in development
  }
}
```

**src/app/(auth)/login/page.tsx:**
```typescript
'use client'

import { useActionState } from 'react'
import { loginAction, type LoginState } from './actions'

/**
 * Login page - minimal design per CONTEXT.md.
 * Just email field, Remember Me checkbox, clear feedback, fast aesthetic.
 */
export default function LoginPage() {
  const [state, formAction, isPending] = useActionState<LoginState | null, FormData>(
    loginAction,
    null
  )

  return (
    <div className="rounded-xl border border-zinc-200 bg-white p-8 shadow-sm dark:border-zinc-800 dark:bg-zinc-900">
      <div className="mb-8 text-center">
        <h1 className="text-2xl font-semibold text-zinc-900 dark:text-zinc-100">
          Conductor
        </h1>
        <p className="mt-2 text-sm text-zinc-600 dark:text-zinc-400">
          Sign in with your email
        </p>
      </div>

      {state?.success ? (
        <SuccessMessage message={state.message} debugUrl={state.debugUrl} />
      ) : (
        <form action={formAction} className="space-y-4">
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-zinc-700 dark:text-zinc-300"
            >
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              autoFocus
              className="mt-1 block w-full rounded-lg border border-zinc-300 px-4 py-2.5 text-zinc-900 placeholder:text-zinc-400 focus:border-zinc-500 focus:outline-none focus:ring-2 focus:ring-zinc-500/20 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-100 dark:placeholder:text-zinc-500 dark:focus:border-zinc-400"
              placeholder="you@company.com"
            />
          </div>

          {/* Remember Me checkbox - extends session to 30 days per CONTEXT.md */}
          <div className="flex items-center">
            <input
              id="rememberMe"
              name="rememberMe"
              type="checkbox"
              className="h-4 w-4 rounded border-zinc-300 text-zinc-900 focus:ring-zinc-500 dark:border-zinc-600 dark:bg-zinc-800"
            />
            <label
              htmlFor="rememberMe"
              className="ml-2 block text-sm text-zinc-700 dark:text-zinc-300"
            >
              Remember me for 30 days
            </label>
          </div>

          {state?.message && !state.success && (
            <p className="text-sm text-red-600 dark:text-red-400">
              {state.message}
            </p>
          )}

          <button
            type="submit"
            disabled={isPending}
            className="w-full rounded-lg bg-zinc-900 px-4 py-2.5 text-sm font-medium text-white transition-colors hover:bg-zinc-800 focus:outline-none focus:ring-2 focus:ring-zinc-500/20 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-zinc-100 dark:text-zinc-900 dark:hover:bg-zinc-200"
          >
            {isPending ? 'Sending...' : 'Send magic link'}
          </button>
        </form>
      )}
    </div>
  )
}

function SuccessMessage({
  message,
  debugUrl,
}: {
  message?: string
  debugUrl?: string
}) {
  return (
    <div className="text-center">
      <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-green-100 dark:bg-green-900/20">
        <svg
          className="h-6 w-6 text-green-600 dark:text-green-400"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
          strokeWidth={2}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
          />
        </svg>
      </div>
      <p className="text-zinc-600 dark:text-zinc-400">
        {message || 'Check your email for a magic link'}
      </p>

      {/* Development only: Show clickable link */}
      {debugUrl && process.env.NODE_ENV === 'development' && (
        <div className="mt-6 rounded-lg border border-yellow-200 bg-yellow-50 p-4 dark:border-yellow-900 dark:bg-yellow-900/20">
          <p className="mb-2 text-xs font-medium text-yellow-800 dark:text-yellow-200">
            Development Only
          </p>
          <a
            href={debugUrl}
            className="text-sm text-yellow-700 underline hover:text-yellow-800 dark:text-yellow-300"
          >
            Click here to sign in
          </a>
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Login page exists at src/app/(auth)/login/page.tsx
3. Server action uses 'use server' directive
  </verify>
  <done>
Login page shows minimal email form. Server action handles magic link request. Success state shows email sent message with development debug link.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create magic link callback and logout</name>
  <files>
src/app/(auth)/magic-link/page.tsx
src/app/(auth)/magic-link/actions.ts
src/app/api/auth/logout/route.ts
  </files>
  <action>
Create magic link callback page that validates tokens and creates sessions, plus logout API route.

**src/app/(auth)/magic-link/actions.ts:**
```typescript
'use server'

import { redirect } from 'next/navigation'
import { validateMagicLinkToken } from '@/lib/auth'
import { createSession } from '@/lib/auth'

export interface MagicLinkState {
  error?: string
}

export async function validateMagicLink(token: string): Promise<MagicLinkState> {
  const result = await validateMagicLinkToken(token)

  if (!result) {
    return { error: 'This magic link is invalid or has expired. Please request a new one.' }
  }

  // In production: Look up user in database by email
  // For development: Create a mock user session
  const mockUser = {
    userId: crypto.randomUUID(),
    email: result.email,
    name: result.email.split('@')[0], // Use email prefix as name for demo
    platform: 'music-vine' as const,
  }

  // Use rememberMe from the magic link token (set during login)
  // Per CONTEXT.md: "Remember me option extends session to 30 days"
  // Session cookies persist across browser sessions when rememberMe is true
  await createSession(mockUser, result.rememberMe)

  // Redirect to dashboard
  redirect('/')
}
```

**src/app/(auth)/magic-link/page.tsx:**
```typescript
'use client'

import { useEffect, useState } from 'react'
import { useSearchParams } from 'next/navigation'
import Link from 'next/link'
import { validateMagicLink, type MagicLinkState } from './actions'

/**
 * Magic link callback page.
 * Validates the token from URL and creates session.
 */
export default function MagicLinkPage() {
  const searchParams = useSearchParams()
  const token = searchParams.get('token')
  const [state, setState] = useState<MagicLinkState | null>(null)
  const [isValidating, setIsValidating] = useState(true)

  useEffect(() => {
    async function validate() {
      if (!token) {
        setState({ error: 'No magic link token provided' })
        setIsValidating(false)
        return
      }

      try {
        // This will redirect on success
        const result = await validateMagicLink(token)
        // If we get here, there was an error (redirect didn't happen)
        setState(result)
      } catch (error) {
        // Server action threw (redirect happened, or actual error)
        // If redirect happened, component unmounts
        setState({ error: 'An unexpected error occurred' })
      } finally {
        setIsValidating(false)
      }
    }

    validate()
  }, [token])

  if (isValidating) {
    return (
      <div className="rounded-xl border border-zinc-200 bg-white p-8 shadow-sm dark:border-zinc-800 dark:bg-zinc-900">
        <div className="flex flex-col items-center">
          <div className="h-8 w-8 animate-spin rounded-full border-2 border-zinc-300 border-t-zinc-900 dark:border-zinc-700 dark:border-t-zinc-100" />
          <p className="mt-4 text-zinc-600 dark:text-zinc-400">
            Signing you in...
          </p>
        </div>
      </div>
    )
  }

  if (state?.error) {
    return (
      <div className="rounded-xl border border-zinc-200 bg-white p-8 shadow-sm dark:border-zinc-800 dark:bg-zinc-900">
        <div className="text-center">
          <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-red-100 dark:bg-red-900/20">
            <svg
              className="h-6 w-6 text-red-600 dark:text-red-400"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              strokeWidth={2}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
          <p className="mb-6 text-zinc-600 dark:text-zinc-400">
            {state.error}
          </p>
          <Link
            href="/login"
            className="inline-flex items-center rounded-lg bg-zinc-900 px-4 py-2.5 text-sm font-medium text-white transition-colors hover:bg-zinc-800 dark:bg-zinc-100 dark:text-zinc-900 dark:hover:bg-zinc-200"
          >
            Back to login
          </Link>
        </div>
      </div>
    )
  }

  return null
}
```

**src/app/api/auth/logout/route.ts:**
```typescript
import { NextResponse } from 'next/server'
import { destroySession } from '@/lib/auth'

export async function POST() {
  await destroySession()

  return NextResponse.json({ success: true })
}

// Also support GET for simple logout links
export async function GET() {
  await destroySession()

  // Redirect to login page
  return NextResponse.redirect(new URL('/login', process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'))
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Magic link page exists at src/app/(auth)/magic-link/page.tsx
3. Logout route exists at src/app/api/auth/logout/route.ts
4. Both POST and GET methods are exported from logout route
  </verify>
  <done>
Magic link callback validates token and creates session, redirecting to dashboard on success. Logout API route destroys session and supports both POST and GET methods.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Login page accessible at /login
3. Magic link callback accessible at /magic-link
4. Logout API available at /api/auth/logout
5. Development mode shows debug URL for magic link testing
</verification>

<success_criteria>
- Login page shows minimal email form (AUTH-01)
- Magic link is generated and logged in development
- Magic link callback creates session and redirects (AUTH-02)
- Logout endpoint destroys session (AUTH-03)
- Error states show clear messages with retry options
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-infrastructure/01-06-SUMMARY.md`
</output>
