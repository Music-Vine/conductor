---
phase: 01-foundation-and-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/error.tsx
  - src/app/global-error.tsx
  - src/components/skeletons/BaseSkeleton.tsx
  - src/components/skeletons/CardSkeleton.tsx
  - src/components/skeletons/TableRowSkeleton.tsx
  - src/components/skeletons/FormSkeleton.tsx
  - src/components/skeletons/index.ts
autonomous: true

must_haves:
  truths:
    - "Route errors display a user-friendly error page with retry option"
    - "Global errors display a minimal fallback UI"
    - "Loading skeletons are available for common UI patterns"
  artifacts:
    - path: "src/app/error.tsx"
      provides: "Route-level error boundary"
      exports: ["default"]
    - path: "src/app/global-error.tsx"
      provides: "Root-level error fallback"
      exports: ["default"]
    - path: "src/components/skeletons/index.ts"
      provides: "Skeleton component exports"
      exports: ["BaseSkeleton", "CardSkeleton", "TableRowSkeleton", "FormSkeleton"]
  key_links:
    - from: "src/app/error.tsx"
      to: "Next.js error handling"
      via: "Error boundary convention"
      pattern: "'use client'"
---

<objective>
Create error boundaries for graceful error handling and loading skeleton components for consistent loading states across the application.

Purpose: These foundational UI components ensure users see helpful error messages instead of crashes and smooth loading states instead of jarring content shifts. Required by UX-06.

Output: Error boundary files in app/, skeleton components in components/skeletons/
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error boundaries</name>
  <files>
src/app/error.tsx
src/app/global-error.tsx
  </files>
  <action>
Create Next.js App Router error boundaries following official patterns.

**src/app/error.tsx** (route segment error boundary):
```typescript
'use client'

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log error to console (error tracking service integration later)
    console.error('Route error:', error)
  }, [error])

  return (
    <div className="flex min-h-[400px] flex-col items-center justify-center gap-4 p-8">
      <div className="rounded-full bg-red-100 p-3 dark:bg-red-900/20">
        <svg
          className="h-6 w-6 text-red-600 dark:text-red-400"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
          strokeWidth={2}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          />
        </svg>
      </div>
      <h2 className="text-xl font-semibold text-zinc-900 dark:text-zinc-100">
        Something went wrong
      </h2>
      <p className="max-w-md text-center text-zinc-600 dark:text-zinc-400">
        {error.message || 'An unexpected error occurred. Please try again.'}
      </p>
      {error.digest && (
        <p className="text-xs text-zinc-400 dark:text-zinc-500">
          Error ID: {error.digest}
        </p>
      )}
      <button
        onClick={reset}
        className="mt-4 rounded-lg bg-zinc-900 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-zinc-800 dark:bg-zinc-100 dark:text-zinc-900 dark:hover:bg-zinc-200"
      >
        Try again
      </button>
    </div>
  )
}
```

**src/app/global-error.tsx** (root-level fallback - must include html/body):
```typescript
'use client'

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <html lang="en">
      <body className="flex min-h-screen items-center justify-center bg-zinc-50 dark:bg-zinc-950">
        <div className="flex flex-col items-center gap-4 p-8 text-center">
          <div className="rounded-full bg-red-100 p-4 dark:bg-red-900/20">
            <svg
              className="h-8 w-8 text-red-600 dark:text-red-400"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              strokeWidth={2}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
          <h1 className="text-2xl font-bold text-zinc-900 dark:text-zinc-100">
            Application Error
          </h1>
          <p className="max-w-md text-zinc-600 dark:text-zinc-400">
            A critical error has occurred. Please refresh the page or try again later.
          </p>
          <button
            onClick={reset}
            className="mt-4 rounded-lg bg-zinc-900 px-6 py-3 font-medium text-white transition-colors hover:bg-zinc-800 dark:bg-zinc-100 dark:text-zinc-900 dark:hover:bg-zinc-200"
          >
            Try again
          </button>
        </div>
      </body>
    </html>
  )
}
```

Both files MUST start with 'use client' directive - error boundaries only work as Client Components in Next.js App Router.
  </action>
  <verify>
1. Both files exist and contain 'use client' directive
2. `npx tsc --noEmit` passes
3. Files follow Next.js error boundary naming convention (error.tsx, global-error.tsx)
  </verify>
  <done>
Error boundaries exist at app/error.tsx and app/global-error.tsx. TypeScript compiles without errors. Both files are client components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create loading skeleton components</name>
  <files>
src/components/skeletons/BaseSkeleton.tsx
src/components/skeletons/CardSkeleton.tsx
src/components/skeletons/TableRowSkeleton.tsx
src/components/skeletons/FormSkeleton.tsx
src/components/skeletons/index.ts
  </files>
  <action>
Create reusable skeleton components using react-loading-skeleton. These will be used across the application for consistent loading states.

First, create the CSS import in globals.css if not already present by adding:
```css
/* In src/app/globals.css, add at the end: */
@import 'react-loading-skeleton/dist/skeleton.css';
```

**src/components/skeletons/BaseSkeleton.tsx:**
```typescript
'use client'

import Skeleton, { SkeletonProps } from 'react-loading-skeleton'

export interface BaseSkeletonProps extends SkeletonProps {
  className?: string
}

export function BaseSkeleton({ className, ...props }: BaseSkeletonProps) {
  return (
    <Skeleton
      baseColor="var(--skeleton-base, #e5e7eb)"
      highlightColor="var(--skeleton-highlight, #f3f4f6)"
      className={className}
      {...props}
    />
  )
}
```

**src/components/skeletons/CardSkeleton.tsx:**
```typescript
'use client'

import { BaseSkeleton } from './BaseSkeleton'

interface CardSkeletonProps {
  hasImage?: boolean
  lines?: number
}

export function CardSkeleton({ hasImage = false, lines = 3 }: CardSkeletonProps) {
  return (
    <div className="rounded-lg border border-zinc-200 p-4 dark:border-zinc-800">
      {hasImage && (
        <BaseSkeleton height={160} className="mb-4 rounded-lg" />
      )}
      <BaseSkeleton width="60%" height={24} className="mb-2" />
      {Array.from({ length: lines }).map((_, i) => (
        <BaseSkeleton
          key={i}
          width={i === lines - 1 ? '80%' : '100%'}
          height={16}
          className="mb-1"
        />
      ))}
    </div>
  )
}
```

**src/components/skeletons/TableRowSkeleton.tsx:**
```typescript
'use client'

import { BaseSkeleton } from './BaseSkeleton'

interface TableRowSkeletonProps {
  columns?: number
  rows?: number
}

export function TableRowSkeleton({ columns = 4, rows = 5 }: TableRowSkeletonProps) {
  return (
    <div className="space-y-2">
      {/* Header */}
      <div className="flex gap-4 border-b border-zinc-200 pb-2 dark:border-zinc-800">
        {Array.from({ length: columns }).map((_, i) => (
          <div key={i} className="flex-1">
            <BaseSkeleton height={20} />
          </div>
        ))}
      </div>
      {/* Rows */}
      {Array.from({ length: rows }).map((_, rowIndex) => (
        <div key={rowIndex} className="flex gap-4 py-2">
          {Array.from({ length: columns }).map((_, colIndex) => (
            <div key={colIndex} className="flex-1">
              <BaseSkeleton height={16} width={colIndex === 0 ? '80%' : '60%'} />
            </div>
          ))}
        </div>
      ))}
    </div>
  )
}
```

**src/components/skeletons/FormSkeleton.tsx:**
```typescript
'use client'

import { BaseSkeleton } from './BaseSkeleton'

interface FormSkeletonProps {
  fields?: number
  hasSubmitButton?: boolean
}

export function FormSkeleton({ fields = 3, hasSubmitButton = true }: FormSkeletonProps) {
  return (
    <div className="space-y-6">
      {Array.from({ length: fields }).map((_, i) => (
        <div key={i} className="space-y-2">
          <BaseSkeleton width={100} height={16} />
          <BaseSkeleton height={40} className="rounded-lg" />
        </div>
      ))}
      {hasSubmitButton && (
        <BaseSkeleton width={120} height={44} className="rounded-lg" />
      )}
    </div>
  )
}
```

**src/components/skeletons/index.ts:**
```typescript
export { BaseSkeleton } from './BaseSkeleton'
export type { BaseSkeletonProps } from './BaseSkeleton'

export { CardSkeleton } from './CardSkeleton'
export { TableRowSkeleton } from './TableRowSkeleton'
export { FormSkeleton } from './FormSkeleton'
```

Also add CSS variables for skeleton colors in globals.css to support dark mode:
```css
:root {
  --skeleton-base: #e5e7eb;
  --skeleton-highlight: #f3f4f6;
}

.dark {
  --skeleton-base: #27272a;
  --skeleton-highlight: #3f3f46;
}
```
  </action>
  <verify>
1. All skeleton files exist in src/components/skeletons/
2. Index file exports all components
3. `npx tsc --noEmit` passes
4. Skeleton CSS is imported in globals.css
  </verify>
  <done>
Four skeleton components (Base, Card, TableRow, Form) exist with proper exports. CSS variables for dark mode theming are configured. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Error boundaries exist at correct paths: src/app/error.tsx, src/app/global-error.tsx
3. Skeleton components can be imported: `import { CardSkeleton, TableRowSkeleton } from '@/components/skeletons'`
4. react-loading-skeleton CSS is imported in globals.css
</verification>

<success_criteria>
- Error boundaries catch and display route-level and global errors with retry functionality
- Loading skeleton components are available for cards, tables, and forms
- Dark mode support via CSS variables
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-infrastructure/01-02-SUMMARY.md`
</output>
