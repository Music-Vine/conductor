---
phase: 01-foundation-and-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["01-03", "01-05"]
files_modified:
  - src/lib/audit/logger.ts
  - src/lib/audit/index.ts
  - src/app/api/audit/route.ts
  - src/hooks/useAuditLog.ts
autonomous: true

must_haves:
  truths:
    - "Audit events can be captured with actor, action, resource, and before/after data"
    - "Audit events are sent to backend API endpoint"
    - "Audit logging is non-blocking (fire-and-forget for performance)"
  artifacts:
    - path: "src/lib/audit/logger.ts"
      provides: "Audit event capture utility"
      exports: ["captureAuditEvent", "createAuditLogger"]
    - path: "src/app/api/audit/route.ts"
      provides: "Mock audit API endpoint"
      exports: ["POST"]
    - path: "src/hooks/useAuditLog.ts"
      provides: "React hook for audit logging"
      exports: ["useAuditLog"]
  key_links:
    - from: "src/hooks/useAuditLog.ts"
      to: "src/lib/audit/logger.ts"
      via: "captureAuditEvent import"
      pattern: "import.*captureAuditEvent"
---

<objective>
Implement audit logging infrastructure for capturing staff actions with before/after state tracking.

Purpose: This enables AUTH-04 (audit trail for all staff actions). Per CONTEXT.md, logs capture field-level changes ("Changed email from X to Y") and all staff can view all logs.

Output: Audit logger utility in lib/audit/, mock API endpoint, React hook for easy use
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-and-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-foundation-and-infrastructure/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit logger utilities</name>
  <files>
src/lib/audit/logger.ts
src/lib/audit/index.ts
  </files>
  <action>
Create audit logging utilities that capture events and send them to the backend API.

**src/lib/audit/logger.ts:**
```typescript
import type { AuditEvent, AuditAction, Platform } from '@/types'

/**
 * Options for capturing an audit event.
 */
export interface CaptureAuditEventOptions {
  actor: string
  action: AuditAction
  resource: string
  platform: Platform
  metadata?: {
    before?: Record<string, unknown>
    after?: Record<string, unknown>
    reason?: string
    [key: string]: unknown
  }
}

/**
 * Captures an audit event and sends it to the backend.
 *
 * This is a fire-and-forget operation - it doesn't await the response
 * to avoid blocking UI operations. Errors are logged but not thrown.
 *
 * @param options - Audit event details
 */
export async function captureAuditEvent(options: CaptureAuditEventOptions): Promise<void> {
  const event: AuditEvent = {
    actor: options.actor,
    action: options.action,
    resource: options.resource,
    platform: options.platform,
    timestamp: Date.now(),
    metadata: options.metadata || {},
  }

  // Fire-and-forget - don't await
  sendAuditEvent(event).catch((error) => {
    console.error('Failed to capture audit event:', error)
  })
}

/**
 * Internal function to send audit event to API.
 */
async function sendAuditEvent(event: AuditEvent): Promise<void> {
  const response = await fetch('/api/audit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(event),
    credentials: 'include',
  })

  if (!response.ok) {
    throw new Error(`Audit API returned ${response.status}`)
  }
}

/**
 * Creates a logger scoped to a specific actor and platform.
 * Useful for components that need to log multiple events.
 */
export function createAuditLogger(actor: string, platform: Platform) {
  return {
    log(
      action: AuditAction,
      resource: string,
      metadata?: CaptureAuditEventOptions['metadata']
    ) {
      return captureAuditEvent({
        actor,
        action,
        resource,
        platform,
        metadata,
      })
    },

    /**
     * Logs an update with before/after state.
     * Automatically calculates changed fields.
     */
    logUpdate(
      action: AuditAction,
      resource: string,
      before: Record<string, unknown>,
      after: Record<string, unknown>
    ) {
      const changes = calculateChanges(before, after)

      return captureAuditEvent({
        actor,
        action,
        resource,
        platform,
        metadata: {
          before,
          after,
          changes, // Summary of what changed
        },
      })
    },
  }
}

/**
 * Calculates a summary of changes between two objects.
 * Returns an array of change descriptions like "email: old@example.com → new@example.com"
 */
function calculateChanges(
  before: Record<string, unknown>,
  after: Record<string, unknown>
): string[] {
  const changes: string[] = []
  const allKeys = new Set([...Object.keys(before), ...Object.keys(after)])

  for (const key of allKeys) {
    const beforeValue = before[key]
    const afterValue = after[key]

    if (JSON.stringify(beforeValue) !== JSON.stringify(afterValue)) {
      const beforeStr = formatValue(beforeValue)
      const afterStr = formatValue(afterValue)
      changes.push(`${key}: ${beforeStr} → ${afterStr}`)
    }
  }

  return changes
}

/**
 * Formats a value for display in change summary.
 */
function formatValue(value: unknown): string {
  if (value === undefined) return '(not set)'
  if (value === null) return '(empty)'
  if (typeof value === 'string') return value || '(empty string)'
  if (typeof value === 'boolean') return value ? 'true' : 'false'
  if (typeof value === 'number') return String(value)
  if (Array.isArray(value)) return `[${value.length} items]`
  if (typeof value === 'object') return '{...}'
  return String(value)
}
```

**src/lib/audit/index.ts:**
```typescript
export {
  captureAuditEvent,
  createAuditLogger,
  type CaptureAuditEventOptions,
} from './logger'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Audit logger exports available from src/lib/audit/index.ts
  </verify>
  <done>
Audit logger provides captureAuditEvent (fire-and-forget) and createAuditLogger (scoped logger with change tracking). Changes are calculated and formatted automatically.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mock audit API endpoint and React hook</name>
  <files>
src/app/api/audit/route.ts
src/hooks/useAuditLog.ts
src/hooks/index.ts
  </files>
  <action>
Create mock API endpoint for audit events and a React hook for easy audit logging in components.

**src/app/api/audit/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server'
import type { AuditEvent } from '@/types'

/**
 * Mock audit API endpoint.
 *
 * In production, this would be handled by the .NET backend.
 * For frontend development, we log events to console and
 * store them in memory for inspection.
 */

// In-memory store for development (reset on server restart)
const auditEvents: AuditEvent[] = []

export async function POST(request: NextRequest) {
  try {
    const event = (await request.json()) as AuditEvent

    // Validate required fields
    if (!event.actor || !event.action || !event.resource || !event.platform) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Add ID and ensure timestamp
    const storedEvent: AuditEvent = {
      ...event,
      id: crypto.randomUUID(),
      timestamp: event.timestamp || Date.now(),
    }

    // Store in memory
    auditEvents.unshift(storedEvent)

    // Keep only last 1000 events in memory
    if (auditEvents.length > 1000) {
      auditEvents.pop()
    }

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.log('\n=== AUDIT EVENT ===')
      console.log(`Actor: ${storedEvent.actor}`)
      console.log(`Action: ${storedEvent.action}`)
      console.log(`Resource: ${storedEvent.resource}`)
      console.log(`Platform: ${storedEvent.platform}`)
      console.log(`Time: ${new Date(storedEvent.timestamp).toISOString()}`)
      if (storedEvent.metadata.changes) {
        console.log('Changes:', storedEvent.metadata.changes)
      }
      console.log('===================\n')
    }

    return NextResponse.json({ success: true, id: storedEvent.id })
  } catch (error) {
    console.error('Error processing audit event:', error)
    return NextResponse.json(
      { error: 'Invalid request body' },
      { status: 400 }
    )
  }
}

export async function GET(request: NextRequest) {
  // Simple list endpoint for development inspection
  const { searchParams } = new URL(request.url)
  const limit = parseInt(searchParams.get('limit') || '50', 10)
  const action = searchParams.get('action')
  const actor = searchParams.get('actor')
  const resource = searchParams.get('resource')

  let filtered = auditEvents

  if (action) {
    filtered = filtered.filter((e) => e.action === action)
  }
  if (actor) {
    filtered = filtered.filter((e) => e.actor === actor)
  }
  if (resource) {
    filtered = filtered.filter((e) => e.resource.includes(resource))
  }

  return NextResponse.json({
    data: filtered.slice(0, limit),
    total: filtered.length,
  })
}
```

**src/hooks/useAuditLog.ts:**
```typescript
'use client'

import { useCallback } from 'react'
import { useAtom } from 'jotai'
import { platformAtom } from '@/atoms'
import { captureAuditEvent, createAuditLogger } from '@/lib/audit'
import type { AuditAction } from '@/types'

interface UseAuditLogOptions {
  userId: string
}

/**
 * React hook for audit logging in components.
 *
 * Automatically includes platform context from Jotai atom.
 *
 * @example
 * const { log, logUpdate } = useAuditLog({ userId: session.userId })
 *
 * // Simple log
 * log('user.viewed', `user:${userId}`)
 *
 * // Update with before/after
 * logUpdate('user.updated', `user:${userId}`, oldData, newData)
 */
export function useAuditLog({ userId }: UseAuditLogOptions) {
  const [platform] = useAtom(platformAtom)

  const log = useCallback(
    (
      action: AuditAction,
      resource: string,
      metadata?: Record<string, unknown>
    ) => {
      captureAuditEvent({
        actor: userId,
        action,
        resource,
        platform,
        metadata,
      })
    },
    [userId, platform]
  )

  const logUpdate = useCallback(
    (
      action: AuditAction,
      resource: string,
      before: Record<string, unknown>,
      after: Record<string, unknown>
    ) => {
      const logger = createAuditLogger(userId, platform)
      logger.logUpdate(action, resource, before, after)
    },
    [userId, platform]
  )

  return {
    log,
    logUpdate,
  }
}
```

**src/hooks/index.ts:**
```typescript
export { useAuditLog } from './useAuditLog'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. API route exists at src/app/api/audit/route.ts
3. Hook exported from src/hooks/index.ts
4. GET endpoint allows inspection of events
  </verify>
  <done>
Mock audit API stores events in memory and logs to console in development. GET endpoint allows inspection. React hook provides easy audit logging with automatic platform context.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `import { captureAuditEvent, createAuditLogger } from '@/lib/audit'` works
3. `import { useAuditLog } from '@/hooks'` works
4. POST to /api/audit creates audit event
5. GET from /api/audit returns recent events
</verification>

<success_criteria>
- Audit events capture actor, action, resource, timestamp, platform (AUTH-04)
- Field-level changes are tracked with before/after state
- Audit logging is non-blocking (fire-and-forget)
- React hook provides easy integration in components
- Development mode logs events to console for visibility
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-infrastructure/01-07-SUMMARY.md`
</output>
