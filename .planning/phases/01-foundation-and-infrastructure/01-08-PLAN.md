---
phase: 01-foundation-and-infrastructure
plan: 08
type: execute
wave: 4
depends_on: ["01-01", "01-04"]
files_modified:
  - src/components/forms/Form.tsx
  - src/components/forms/FormField.tsx
  - src/components/forms/FormInput.tsx
  - src/components/forms/FormSelect.tsx
  - src/components/forms/FormTextarea.tsx
  - src/components/forms/index.ts
  - src/lib/validation/schemas.ts
  - src/lib/validation/index.ts
autonomous: true

must_haves:
  truths:
    - "Forms validate on blur with inline error messages below fields"
    - "Invalid fields show red border and error icon"
    - "Valid fields show green checkmark"
    - "Form components integrate React Hook Form with Zod schemas"
  artifacts:
    - path: "src/components/forms/Form.tsx"
      provides: "Form wrapper component"
      exports: ["Form"]
    - path: "src/components/forms/FormField.tsx"
      provides: "Field wrapper with label and error"
      exports: ["FormField"]
    - path: "src/components/forms/FormInput.tsx"
      provides: "Validated text input"
      exports: ["FormInput"]
    - path: "src/lib/validation/schemas.ts"
      provides: "Common Zod schemas"
      exports: ["emailSchema", "passwordSchema"]
  key_links:
    - from: "src/components/forms/Form.tsx"
      to: "react-hook-form"
      via: "FormProvider"
      pattern: "FormProvider"
    - from: "src/components/forms/FormField.tsx"
      to: "react-hook-form"
      via: "useFormContext"
      pattern: "useFormContext"
---

<objective>
Create reusable form components with React Hook Form integration, Zod validation, and visual feedback states (blur validation, inline errors, valid checkmarks).

Purpose: This enables UX-05 (forms with real-time validation and clear error messages). Per CONTEXT.md decisions: validate on blur, inline errors below fields, red border + error icon on invalid, green checkmark on valid.

Output: Form components in components/forms/, validation schemas in lib/validation/
</objective>

<execution_context>
@/Users/sambeevors/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sambeevors/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-and-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create form wrapper and field components</name>
  <files>
src/components/forms/Form.tsx
src/components/forms/FormField.tsx
src/components/forms/index.ts
  </files>
  <action>
Create the form wrapper and field components that integrate React Hook Form.

**src/components/forms/Form.tsx:**
```typescript
'use client'

import {
  FormProvider,
  useForm,
  type UseFormProps,
  type FieldValues,
  type SubmitHandler,
} from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import type { ZodSchema } from 'zod'
import type { ReactNode } from 'react'

interface FormProps<T extends FieldValues> {
  schema: ZodSchema<T>
  defaultValues?: UseFormProps<T>['defaultValues']
  onSubmit: SubmitHandler<T>
  children: ReactNode
  className?: string
}

/**
 * Form wrapper that integrates React Hook Form with Zod validation.
 *
 * Per CONTEXT.md:
 * - Validates on blur (mode: 'onBlur')
 * - Re-validates on change after first error (reValidateMode: 'onChange')
 *
 * @example
 * <Form schema={userSchema} defaultValues={{ email: '' }} onSubmit={handleSubmit}>
 *   <FormInput name="email" label="Email" type="email" />
 *   <button type="submit">Submit</button>
 * </Form>
 */
export function Form<T extends FieldValues>({
  schema,
  defaultValues,
  onSubmit,
  children,
  className = '',
}: FormProps<T>) {
  const methods = useForm<T>({
    resolver: zodResolver(schema),
    mode: 'onBlur',
    reValidateMode: 'onChange',
    defaultValues,
  })

  return (
    <FormProvider {...methods}>
      <form
        onSubmit={methods.handleSubmit(onSubmit)}
        className={className}
        noValidate // Use Zod validation, not browser validation
      >
        {children}
      </form>
    </FormProvider>
  )
}
```

**src/components/forms/FormField.tsx:**
```typescript
'use client'

import { useFormContext } from 'react-hook-form'
import type { ReactNode } from 'react'

interface FormFieldProps {
  name: string
  label?: string
  description?: string
  children: ReactNode
  className?: string
}

/**
 * Field wrapper that provides label, error message, and validation state.
 *
 * Per CONTEXT.md:
 * - Error messages appear inline below field
 * - Red border + error icon on invalid fields
 * - Green checkmark on valid fields (when touched and valid)
 */
export function FormField({
  name,
  label,
  description,
  children,
  className = '',
}: FormFieldProps) {
  const {
    formState: { errors, touchedFields },
    getFieldState,
  } = useFormContext()

  const fieldState = getFieldState(name)
  const error = errors[name]
  const isTouched = touchedFields[name]
  const isValid = isTouched && !error

  return (
    <div className={`space-y-1.5 ${className}`}>
      {label && (
        <label
          htmlFor={name}
          className="flex items-center gap-2 text-sm font-medium text-zinc-700 dark:text-zinc-300"
        >
          {label}
          {/* Valid checkmark */}
          {isValid && (
            <svg
              className="h-4 w-4 text-green-500"
              fill="currentColor"
              viewBox="0 0 20 20"
              aria-hidden="true"
            >
              <path
                fillRule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                clipRule="evenodd"
              />
            </svg>
          )}
        </label>
      )}
      {description && (
        <p className="text-sm text-zinc-500 dark:text-zinc-400">{description}</p>
      )}
      <div className="relative">
        {children}
        {/* Error icon (absolute positioned in input) */}
        {error && (
          <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
            <svg
              className="h-5 w-5 text-red-500"
              fill="currentColor"
              viewBox="0 0 20 20"
              aria-hidden="true"
            >
              <path
                fillRule="evenodd"
                d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z"
                clipRule="evenodd"
              />
            </svg>
          </div>
        )}
      </div>
      {/* Error message */}
      {error && (
        <p className="text-sm text-red-600 dark:text-red-400" role="alert">
          {error.message as string}
        </p>
      )}
    </div>
  )
}
```

**src/components/forms/index.ts** (initial):
```typescript
export { Form } from './Form'
export { FormField } from './FormField'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Form and FormField are exported from index.ts
3. Both files use 'use client' directive
  </verify>
  <done>
Form wrapper integrates React Hook Form with Zod resolver and blur validation. FormField provides label, description, error display, and validation icons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create input components and validation schemas</name>
  <files>
src/components/forms/FormInput.tsx
src/components/forms/FormSelect.tsx
src/components/forms/FormTextarea.tsx
src/components/forms/index.ts
src/lib/validation/schemas.ts
src/lib/validation/index.ts
  </files>
  <action>
Create form input components and common validation schemas.

**src/components/forms/FormInput.tsx:**
```typescript
'use client'

import { useFormContext } from 'react-hook-form'
import { FormField } from './FormField'

interface FormInputProps {
  name: string
  label?: string
  type?: 'text' | 'email' | 'password' | 'number' | 'tel' | 'url'
  placeholder?: string
  description?: string
  disabled?: boolean
  autoComplete?: string
  className?: string
}

/**
 * Text input with form integration and validation styling.
 */
export function FormInput({
  name,
  label,
  type = 'text',
  placeholder,
  description,
  disabled,
  autoComplete,
  className = '',
}: FormInputProps) {
  const { register, formState: { errors } } = useFormContext()
  const hasError = !!errors[name]

  return (
    <FormField name={name} label={label} description={description} className={className}>
      <input
        id={name}
        type={type}
        placeholder={placeholder}
        disabled={disabled}
        autoComplete={autoComplete}
        aria-invalid={hasError}
        {...register(name)}
        className={`
          block w-full rounded-lg border px-4 py-2.5 pr-10
          text-zinc-900 placeholder:text-zinc-400
          focus:outline-none focus:ring-2 focus:ring-offset-0
          disabled:cursor-not-allowed disabled:bg-zinc-50 disabled:text-zinc-500
          dark:bg-zinc-800 dark:text-zinc-100 dark:placeholder:text-zinc-500
          ${
            hasError
              ? 'border-red-500 focus:border-red-500 focus:ring-red-500/20'
              : 'border-zinc-300 focus:border-zinc-500 focus:ring-zinc-500/20 dark:border-zinc-700 dark:focus:border-zinc-400'
          }
        `}
      />
    </FormField>
  )
}
```

**src/components/forms/FormSelect.tsx:**
```typescript
'use client'

import { useFormContext } from 'react-hook-form'
import { FormField } from './FormField'

interface FormSelectOption {
  value: string
  label: string
}

interface FormSelectProps {
  name: string
  label?: string
  options: FormSelectOption[]
  placeholder?: string
  description?: string
  disabled?: boolean
  className?: string
}

/**
 * Select input with form integration and validation styling.
 */
export function FormSelect({
  name,
  label,
  options,
  placeholder,
  description,
  disabled,
  className = '',
}: FormSelectProps) {
  const { register, formState: { errors } } = useFormContext()
  const hasError = !!errors[name]

  return (
    <FormField name={name} label={label} description={description} className={className}>
      <select
        id={name}
        disabled={disabled}
        aria-invalid={hasError}
        {...register(name)}
        className={`
          block w-full appearance-none rounded-lg border bg-white px-4 py-2.5 pr-10
          text-zinc-900
          focus:outline-none focus:ring-2 focus:ring-offset-0
          disabled:cursor-not-allowed disabled:bg-zinc-50 disabled:text-zinc-500
          dark:bg-zinc-800 dark:text-zinc-100
          ${
            hasError
              ? 'border-red-500 focus:border-red-500 focus:ring-red-500/20'
              : 'border-zinc-300 focus:border-zinc-500 focus:ring-zinc-500/20 dark:border-zinc-700 dark:focus:border-zinc-400'
          }
        `}
      >
        {placeholder && (
          <option value="" disabled>
            {placeholder}
          </option>
        )}
        {options.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
    </FormField>
  )
}
```

**src/components/forms/FormTextarea.tsx:**
```typescript
'use client'

import { useFormContext } from 'react-hook-form'
import { FormField } from './FormField'

interface FormTextareaProps {
  name: string
  label?: string
  placeholder?: string
  description?: string
  disabled?: boolean
  rows?: number
  className?: string
}

/**
 * Textarea with form integration and validation styling.
 */
export function FormTextarea({
  name,
  label,
  placeholder,
  description,
  disabled,
  rows = 4,
  className = '',
}: FormTextareaProps) {
  const { register, formState: { errors } } = useFormContext()
  const hasError = !!errors[name]

  return (
    <FormField name={name} label={label} description={description} className={className}>
      <textarea
        id={name}
        placeholder={placeholder}
        disabled={disabled}
        rows={rows}
        aria-invalid={hasError}
        {...register(name)}
        className={`
          block w-full rounded-lg border px-4 py-2.5
          text-zinc-900 placeholder:text-zinc-400
          focus:outline-none focus:ring-2 focus:ring-offset-0
          disabled:cursor-not-allowed disabled:bg-zinc-50 disabled:text-zinc-500
          dark:bg-zinc-800 dark:text-zinc-100 dark:placeholder:text-zinc-500
          ${
            hasError
              ? 'border-red-500 focus:border-red-500 focus:ring-red-500/20'
              : 'border-zinc-300 focus:border-zinc-500 focus:ring-zinc-500/20 dark:border-zinc-700 dark:focus:border-zinc-400'
          }
        `}
      />
    </FormField>
  )
}
```

**Update src/components/forms/index.ts:**
```typescript
export { Form } from './Form'
export { FormField } from './FormField'
export { FormInput } from './FormInput'
export { FormSelect } from './FormSelect'
export { FormTextarea } from './FormTextarea'
```

**src/lib/validation/schemas.ts:**
```typescript
import { z } from 'zod'

/**
 * Common validation schemas for reuse across forms.
 */

export const emailSchema = z
  .string()
  .min(1, 'Email is required')
  .email('Please enter a valid email address')

export const passwordSchema = z
  .string()
  .min(8, 'Password must be at least 8 characters')
  .regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
    'Password must contain at least one uppercase letter, one lowercase letter, and one number'
  )

export const nameSchema = z
  .string()
  .min(2, 'Name must be at least 2 characters')
  .max(100, 'Name must be less than 100 characters')

export const urlSchema = z
  .string()
  .url('Please enter a valid URL')
  .or(z.literal('')) // Allow empty string

export const phoneSchema = z
  .string()
  .regex(/^\+?[1-9]\d{1,14}$/, 'Please enter a valid phone number')
  .or(z.literal(''))

/**
 * Helper to make a schema optional (allows empty string).
 */
export function optional<T extends z.ZodTypeAny>(schema: T) {
  return schema.or(z.literal(''))
}

/**
 * Confirmation field helper (e.g., password confirmation).
 */
export function confirmationSchema<T extends z.ZodString>(
  schema: T,
  fieldName: string,
  confirmFieldName: string,
  message = `${fieldName} and ${confirmFieldName} must match`
) {
  return z
    .object({
      [fieldName]: schema,
      [confirmFieldName]: z.string(),
    })
    .refine((data) => data[fieldName] === data[confirmFieldName], {
      message,
      path: [confirmFieldName],
    })
}

/**
 * Example user schema combining multiple fields.
 */
export const userFormSchema = z.object({
  email: emailSchema,
  name: nameSchema,
  role: z.enum(['admin', 'editor', 'viewer'], {
    errorMap: () => ({ message: 'Please select a role' }),
  }),
})

export type UserFormData = z.infer<typeof userFormSchema>
```

**src/lib/validation/index.ts:**
```typescript
export {
  emailSchema,
  passwordSchema,
  nameSchema,
  urlSchema,
  phoneSchema,
  optional,
  confirmationSchema,
  userFormSchema,
  type UserFormData,
} from './schemas'
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. All form components exported from src/components/forms/index.ts
3. Validation schemas exported from src/lib/validation/index.ts
4. FormInput, FormSelect, FormTextarea have proper error styling
  </verify>
  <done>
Form input components (Input, Select, Textarea) created with validation styling. Common validation schemas (email, password, name) available for reuse. All components integrate with React Hook Form context.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `import { Form, FormInput, FormSelect } from '@/components/forms'` works
3. `import { emailSchema, userFormSchema } from '@/lib/validation'` works
4. Form components show red border on invalid fields
5. Form components show green checkmark on valid fields after blur
</verification>

<success_criteria>
- Forms use blur validation with re-validation on change after errors (UX-05)
- Invalid fields have red border and error icon
- Valid fields have green checkmark indicator
- Error messages display inline below fields
- Common validation schemas are reusable (email, password, name)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-infrastructure/01-08-SUMMARY.md`
</output>
